--- 
title: "Manual de R"
author: |
  | Freddy Hernández Barajas
  | Olga Cecilia Usuga Manco
date: "`r Sys.Date()`"
documentclass: krantz
fontsize: 10pt
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
colorlinks: yes
lot: yes
lof: yes
site: bookdown::bookdown_site
description: "A book example for a Chapman & Hall book."
github-repo: yihui/bookdown-crc
#cover-image: images/cover.jpg
---

```{r setup, include=FALSE}
options(
  htmltools.dir.version = FALSE, formatR.indent = 2, width = 55, digits = 4
)

# install the packages needed by this book; you fill out c(), e.g. c('ggplot2', 'dplyr')
lapply(c(), function(pkg) {
  if (system.file(package = pkg) == '') install.packages(pkg)
})
```

# Prefacio {-}

Este libro fue creado con la intención de apoyar el aprendizaje del lenguaje de programación \proglang{R} en estudiantes de pregrado, especialización, maestría e investigadores, que necesiten realizar análisis estadísticos. En este libro se explica de una forma sencilla la utilidad de la principales funciones para realizar diversos análisis estadísticos, las cuestiones sobre creación de gráficos estadísticos no son abordadas en el presente libro, recomendamos consultar @correa_hernandez.

## Estructura del libro {-}

El libro está estructurado de la siguiente manera.

En el capítulo \@ref(central) se muestra como obtener las diversas medidas de tendencial central para variables cuantitativas, el capítulo \@ref(varia) muestra como calcular las medidas de variabilidad, en el capítulo \@ref(posi) se ilustra cómo usar las funciones para obtener medidas de posición y en el capítulo \@ref(correl) se muestra como obtener medidas de correlación entre pares de variables.

## Información del software y convenciones {-}

Para realizar este libro se usaron los paquetes de \proglang{R} **knitr**\index{knitr} [@xie2015] y **bookdown**\index{bookdown} [@R-bookdown], estos paquetes permiten construir todo el libro desde \proglang{R} y sirven para incluir código que se ejecute de forma automática incluyendo las salidas y gráficos.

En todo el libro se presentarán códigos que el lector puede copiar y pegar en su consola de \proglang{R} para obtener los mismos resultados aquí presentados. Los códigos se destacan en una caja de color beis (o beige) similar a la mostrada a continuación.

```{r, eval=F}
4 + 6
a <- c(1, 5, 6)
5 * a
1:10
```

Los resultados o salidas obtenidos de cualquier código se destacan con dos símbolos de númeral (`##`) al inicio de cada línea o renglón, esto quiere decir que todo lo que inicie con `##` son resultados obtenidos y el usuario __NO__ los debe copiar. Abajo se muestran los resultados obtenidos luego de correr el código anterior.

```{r, echo=F}
4 + 6
a <- c(1, 5, 6)
5 * a
1:10
```

## Bloques informativos {-}
En varias partes del libro usaremos bloques informativos para resaltar algún aspecto importante. Abajo se encuentra un ejemplo de los bloques y su significado.

```{block2, type='rmdnote'}
Nota aclaratoria.
```

```{block2, type='rmdtip'}
Sugerencia.
```

```{block2, type='rmdwarning'}
Advertencia.
```



## Agradecimientos {-}

Agradecemos enormemente a todos los estudiantes, profesores e investigadores que han leído este libro y nos han retroalimentado con comentarios valiosos para mejorar el documento.

```{block2, type='flushright', html.tag='p'}
Freddy Hernández Barajas

Olga Cecilia Usuga Manco
```


<!--chapter:end:index.Rmd-->

# Sobre los autores {-}

Freddy Hernández Barajas es profesor asistente de la Universidad Nacional de Colombia adscrito a la Escuela de Estadística de la Facultad de Ciencias.

Olga Cecilia Usuga Manco es profesora asociada de la Universidad de Antioquia adscrita al Departamento de Ingeniería Industrial de la Facultad de Ingeniería.

<!--chapter:end:00-author.Rmd-->

\mainmatter

# Introducción 

\section{Orígenes} \label{sec:origenes}
\proglang{R} es un lenguaje de programación usado para realizar procedimientos estadísticos y gráficos de alto nivel, este lenguaje fue creado en 1993 por los profesores e investigadores Robert Gentleman y Ross Ihaka. Inicialmente el lenguaje se usó para apoyar los cursos que tenían a su cargo los profesores, pero luego de ver la utilidad de la herramienta desarrollada, decidieron colocar copias de \proglang{R} en StatLib. A partir de 1995 el código fuente de \proglang{R} está disponible bajo licencia GNU GPL para sistemas operativos Windows, Macintosh y distribuciones Unix/Linux. La comunidad de usuarios de \proglang{R} en el mundo es muy grande y los usuarios cuentan con diferentes espacios para interactuar, a continuación una lista no exhaustiva de los sitios más populares relacionados con \proglang{R}:

- [Rbloggers](https://www.r-bloggers.com/).
- [Comunidad hispana de \proglang{R}](http://r-es.org/).
- [Nabble](http://r.789695.n4.nabble.com/).
- [Foro en portugués](http://r-br.2285057.n4.nabble.com/).
- [Stackoverflow](http://stackoverflow.com/questions/tagged/r).
- [Cross Validated](http://stats.stackexchange.com/questions/tagged/r).
- [\proglang{R}-Help Mailing List](https://stat.ethz.ch/mailman/listinfo/r-help).
- [Revolutions](http://blog.revolutionanalytics.com/).
- [\proglang{R}-statistics blog](https://www.r-statistics.com/).
- [RDataMining](https://rdatamining.wordpress.com/).

```{r, echo=F, fig.cap='Robert Gentleman (izquierda) y Ross Ihaka (derecha) creadores de R.', dpi=200, fig.align='center'}
knitr::include_graphics("images/Robert_Roos.png")
```

\section{Descarga e instalación} \label{sec:descarga}

Para realizar la instalación de \proglang{R} usted debe visitar la página del CRAN (\textit{Comprehensive R Archive Network}) disponible en este [enlace](https://cran.r-project.org/). Una vez ingrese a la página encontrará un cuadro similar al mostrado en la Figura \@ref(fig:cran) donde aparecen los enlaces de la instalación para los sistemas operativos Linux, Mac y Windows.

```{r cran, echo=F, fig.cap='Página del Cran.', dpi=190, fig.align='center'}
knitr::include_graphics("images/cran.png")
```

Supongamos que se desea instalar \proglang{R} en Windows, para esto se debe dar clic sobre el hiperenlace \textcolor{BurntOrange}{Download R for Windows} de la Figura \@ref(fig:cran). Una vez hecho esto se abrirá una página con el contenido mostrado en la Figura \@ref(fig:inst1). Una vez ingrese a esa nueva página usted debe dar clic sobre el hiperenlace \textcolor{BurntOrange}{install R for the first time} como es señalado por la flecha roja en la Figura \@ref(fig:inst1).
  
```{r inst1, echo=F, fig.cap='Página de instalación para la primera ocasión.', dpi=190, fig.align='center'}
knitr::include_graphics("images/instalacion1.png")
```

Luego de esto se abrirá otra página con un encabezado similar al mostrado en la Figura \@ref(fig:inst2), al momento de capturar la figura la versión actual de \proglang{R} era 3.2.5 pero seguramente en este momento usted tendrá disponible una versión actualizada. Una vez allí uste debe dar clic sobre \textcolor{BurntOrange}{Download R 3.2.5 for Windows} como es señalado por la flecha verde. Luego de esto se descargará el instalador \proglang{R} en el computador el cual deberá ser instalado con las opciones que vienen por defecto.

```{r inst2, echo=F, fig.cap='Página de descarga.', dpi=190, fig.align='center'}
knitr::include_graphics("images/instalacion2.png")
```

Se recomienda observar el siguiente video didáctico de instalación de \proglang{R} disponible en este [enlace](http://tinyurl.com/jd7b9ks) para facilitar la tarea de instalación.

\section{Apariencia del programa} \label{sec:apariencia}
Una vez que esté instalado \proglang{R} en su computador, usted podrá acceder a él por la lista de programas o por medio del acceso directo que quedó en el escritorio, en la Figura \@ref(fig:rlogo) se muestra la apariencia del acceso directo para ingresar a \proglang{R}.

```{r rlogo, echo=F, fig.cap='Apariencia del acceso directo para ingresar a R.', dpi=700, fig.align='center'}
knitr::include_graphics("images/rlogo.png")
```

Al abrir \proglang{R} aparecerá en la pantalla de su computador algo similar a lo que está en la Figura \@ref(fig:pantalla). La ventana izquierda se llama consola y es donde se ingresan las instrucciones, una vez que se construye un gráfico se activa otra ventana llamada ventana gráfica. Cualquier usuario puede modificar la posición y tamaños de estas ventanas, puede cambiar el tipo y tamaño de las letras en la consola, para hacer esto se deben explorar las opciones de \textit{editar} en la barra de herramientas.

```{r pantalla, echo=F, fig.cap='Apariencia de R.', dpi=400, fig.align='center'}
knitr::include_graphics("images/Rpantallazo.png")
```




<!--chapter:end:01_intro.Rmd-->

# Tipos de objetos \index{objetos} \label{objetos}

En \proglang{R} existen varios tipos de objectos que permiten que el usuario pueda almacenar la información para realizar procedimientos estadísticos y gráficos. Los principales objetos en \proglang{R} son vectores, matrices, arreglos, marcos de datos y listas. A continuación se presentan las características de estos objetos y la forma para crearlos.

## Vectores \index{vector} \label{vector}

Los vectores vectores son arreglos ordenados en los cuales se puede almacenar información de tipo numérico (variable cuantitativa), alfanumérico (variable cualitativa) o lógico (`TRUE` o `FALSE`), pero no mezclas de éstos. La función de \proglang{R} para crear un vector es `c()` y que significa concatenar; dentro de los paréntesis de esta función se ubica la información a almacenar. Una vez construído el vector se acostumbra a etiquetarlo con un nombre corto y representativo de la información que almacena, la asignación se hace por medio del operador `<-` entre el nombre y el vector.

A continuación se presenta un ejemplo de cómo crear tres vectores que contienen las respuestas de cinco personas a tres preguntas que se les realizaron.

```{r}
edad <- c(15, 19, 13, NA, 20)
deporte <- c(TRUE, TRUE, NA, FALSE, TRUE)
comic.fav <- c(NA, 'Superman', 'Batman', NA, 'Batman')
```

El vector `edad` es un vector cuantitativo y contiene las edades de las 5 personas. En la cuarta posición del vector se colocó el símbolo `NA` que significa \textit{Not Available} debido a que no se registró la edad para esa persona. Al hacer una asignación se acostumbra a dejar un espacio antes y después del operador `<-` de asignación. El segundo vector es llamado `deporte` y es un vector lógico que almacena las respuestas a la pregunta de si la persona practica deporte, nuevamente aquí hay un `NA` para la tercera persona. El último vector `comic.fav` contiene la información del cómic favorito de cada persona, como esta variable es cualitativa es necesario usar las comillas `' '` para encerrar las respuestas. 

```{block2, type='rmdwarning'}
Cuando se usa `NA` para representar una información \textit{Not Available} no se deben usar comillas.
```

```{block2, type='rmdnote'}
Es posible usar comillas sencillas `'foo'` o comillas dobles `"foo"` para ingresar valores de una variable cualitativa.
```

Si se desea ver lo que está almacenado en cada uno de estos vectores, se debe escribir en la consola de \proglang{R} el nombre de uno de los objetos y luego se presiona la tecla \textit{enter} o \textit{intro}, al realizar esto lo que se obtiene se muestra a continuación.

```{r}
edad
deporte
comic.fav
```

### ¿Cómo extraer elementos de un vector?
Para extraer un elemento almacenado dentro un vector se usan los corchetes `[]` y dentro de ellos la posición o posiciones que interesan.

### Ejemplo {-}
Si queremos extraer la edad de la tercera persona escribimos el nombre del vector y luego `[3]` para indicar la tercera posición de `edad`, a continuación el código.

```{r}
edad[3]
```

Si queremos conocer el cómic favorito de la segunda y quinta persona, escribimos el nombre del vector y luego, dentro de los corchetes, escribimos otro vector con las posiciones 2 y 5 que nos interesan así `[c(2, 5)]`, a continuación el código. 

```{r}
comic.fav[c(2, 5)]
```

Si nos interesan las respuestas de la práctica de deporte, excepto la de la persona 3, usamos `[-3]` luego del nombre del vector para obtener todo, excepto la tercera posición.

```{r}
deporte[-3]
```

```{block2, type='rmdwarning'}
Si desea extraer varios posiciones de un vector NUNCA escriba esto: `mivector[2, 5, 7]`. Tiene que crear un vector con las posiciones y luego colocarlo dentro de los corchetes así: `mivector[c(2, 5, 7)]`
```

## Matrices
Las matrices \index{matrices} son arreglos rectangulares de filas y columnas con información numérica, alfanumérica o lógica. Para construir una matriz se usa la función `matrix( )`. Por ejemplo, para crear una matriz de 4 filas y 5 columnas (de dimensión $4 \times 5$) con los primeros 20 números positivos se escribe el código siguiente en la consola.

```{r}
mimatriz <- matrix(data=1:20, nrow=4, ncol=5, byrow=FALSE)
```

El argumento `data` de la función sirve para indicar los datos que se van a almacenar en la matriz, los argumentos `nrow` y `ncol` sirven para definir la dimensión de la matriz y por último el argumento `byrow` sirve para indicar si la información contenida en `data` se debe ingresar por filas o no. Para observar lo que quedó almacenado en el objeto `mimatriz` se escribe en la consola el nombre del objeto seguido de la tecla \textit{enter} o \textit{intro}.

```{r}
mimatriz
```

### ¿Cómo extraer elementos de una matriz?
Al igual que en el caso de los vectores, para extraer elementos almacenados dentro de una matriz se usan los corchetes `[ , ]` y dentro, separado por una coma, el número de fila(s) y el número de columna(s) que nos interesan.

### Ejemplo {-}
Si queremos extraer el valor almacenado en la fila 3 y columna 4 usamos el siguiente código.
```{r}
mimatriz[3, 4]
```

Si queremos recuperar __toda__ la fila 2 usamos el siguiente código.
```{r}
mimatriz[2, ]  # No se escribe nada luego de la coma
```

Si queremos recuperar __toda__ la columna 5 usamos el siguiente código.
```{r}
mimatriz[, 5]  # No se escribe nada antes de la coma
```

Si queremos recuperar la matriz original sin las columnas 2 y 4 usamos el siguiente código.
```{r}
mimatriz[, -c(2, 4)]  # Las columnas como vector
```

Si queremos recuperar la matriz original sin la fila 1 ni columna 3 usamos el siguiente código.
```{r}
mimatriz[-1, -3]  # Signo de menos para eliminar
```

## Arreglos \index{arreglo} \index{array}

Un arreglo es una matriz de varias dimensiones con información numérica, alfanumérica o lógica. Para construir una arreglo se usa la función `array( )`. Por ejemplo, para crear un arreglo de $3 \times 4 \times 2$ con las primeras 24 letras minúsculas del alfabeto se escribe el siguiente código.

```{r}
miarray <- array(data=letters[1:24], dim=c(3, 4, 2))
```

El argumento `data` de la función sirve para indicar los datos que se van a almacenar en el arreglo y el argumento `dim` sirve para indicar las dimensiones del arreglo. Para observar lo que quedó almacenado en el objeto `miarray` se escribe en la consola lo siguiente.

```{r}
miarray
```

### ¿Cómo extraer elementos de un arreglo?
Para recuperar elementos almacenados en un arreglo se usan también corchetes, y dentro de los corchetes, las coordenadas del objeto de interés.

### Ejemplo {-}
Si queremos extraer la letra almacenada en la fila 1 y columna 3 de la segunda capa de `miarray` usamos el siguiente código.
```{r}
miarray[1, 3, 2]  # El orden es importante
```

Si queremos extraer la segunda capa completa usamos el siguiente código.
```{r}
miarray[,, 2]  # No se coloca nada en las primeras posiciones
```

Si queremos extraer la tercera columna de todas las capas usamos el siguiente código.
```{r}
miarray[, 3,]  # No se coloca nada en las primeras posiciones
```


## Marco de datos \index{marco de datos} \index{data.frame} \label{marcodatos} \label{marcodatos}
El marco de datos marco de datos o _data frame_ es uno de los objetos más utilizados porque permite agrupar vectores con información de diferente tipo (numérica, alfanumérica o lógica) en un mismo objeto, la única restricción es que los vectores deben tener la misma longitud. Para crear un marco de datos se usa la función `data.frame( )`, como ejemplo vamos a crear un marco de datos con los vectores `edad`, `deporte` y `comic.fav` definidos anteriormente.

```{r}
mimarco <- data.frame(edad, deporte, comic.fav)
```

Una vez creado el objeto `mimarco` podemos ver el objeto escribiendo su nombre en la consola, a continuación se muestra lo que se obtiene.

```{r}
mimarco
```

De la salida anterior vemos que el marco de datos tiene 3 variables (columnas) cuyos nombres coinciden con los nombres de los vectores creados anteriormente, los números consecutivos al lado izquierdo son sólo de referencia y permiten identificar la información para cada persona en la base de datos.

### ¿Cómo extraer elementos de un marco de datos?
Para recuperar las variables (columnas) almacenadas en un marco de datos se puede usar el operador `$` o también corchetes `[]`. A continuación algunos ejemplos para entender el uso del operador `$`.


### Ejemplo {-}
Si queremos extraer la variable `deporte` del marco de datos `mimarco` usamos el siguiente código.
```{r}
mimarco$deporte  # Se recomienda si el nombre es corto
```

Otra forma de recuperar la variable `deporte` es indicando la columna donde se encuentra la variable
```{r}
mimarco[, 2]  # Se recomienda si recordamos su ubicacion
```

Si queremos la `edad` de las personas que están en las posiciones 2 hasta 4 usamos el siguiente código.
```{r}
mimarco[2:4, 1]
```

### ¿Cómo extraer subconjuntos de un marco de datos? \index{subset}
Para extraer partes de un marco de datos se puede utilizar la función `subset(x, subset, select)`. El parámetro `x` sirve para indicar el marco de datos original, el parámetro `subset` sirve para colocar la condición y el parámetro `select` sirve para quedarnos sólo con algunas de las variables del marco de datos. A continuación varios ejemplos de la función `subset` para ver su utilidad.

### Ejemplos {-}
Si queremos el marco de datos `mimarco` sólo con las personas que SI practican deporte usamos el siguiente código.
```{r}
subset(mimarco, subset=deporte == TRUE)
```

Si queremos el marco de datos `mimarco` sólo con las personas mayores o iguales a 17 años usamos el siguiente código.
```{r}
subset(mimarco, subset=edad >= TRUE)
```

Si queremos el submarco con deporte y comic de las personas menores de 20 años usamos el siguiente código.
```{r}
subset(mimarco, subset=edad < 20, select=c('deporte', 'comic.fav'))
```

Si queremos el marco de datos `mimarco` sólo con las personas menores de 20 años y que SI practican deporte usamos el siguiente código.
```{r}
subset(mimarco, subset=edad < 20 & deporte == TRUE)
```

### Ejemplo {-}
Leer la base de datos medidas del cuerpo disponible en este enlace https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo. Extraer de esta base de datos una sub-base o subconjunto que contenga sólo la edad, peso, altura y sexo de aquellos que miden más de 185 cm y pesan más de 80 kg.

```{r}
url <- 'https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo'
dt1 <- read.table(url, header=T)
dim(dt1)  # Para conocer la dimensión de la base original
dt2 <- subset(x=dt1, subset=altura > 185 & peso > 80,
              select=c('sexo', 'edad', 'peso', 'altura'))
dt2  # Para mostrar la base de datos final
```
Al almacenar la nueva base de datos en el objeto `dt2` se puede manipular este nuevo objeto para realizar los análisis de interés.

## Listas \index{lista} \index{list}

Las listas son otro tipo de objeto muy usado para almacenar objetos de diferente tipo. La instrucción para crear una lista es `list( )`. A continuación vamos a crear una lista que contiene tres objetos: un vector con 5 números aleatorios llamado `mivector`, una matriz de dimensión $6 \times 2$ con los primeros doce números enteros positivos llamada `matriz2` y el tercer objeto será el marco de datos `mimarco` creado en el apartado anterior. Las instrucciones para crear la lista requerida se muestran a continuación.

```{r}
set.seed(12345)
mivector <- runif(n=5)
matriz2 <- matrix(data=1:12, ncol=6)
milista <- list(E1=mivector, E2=matriz2, E3=mimarco)
```

La función `set.seed` de la línea número 1 sirve para fijar la semilla de tal manera que los números aleatorios generados en la segunda línea con la función `runif` sean siempre los mismos. En la última línea del código anterior se construye la lista, dentro de la función `list` se colocan los tres objetos `mivector`, `matriz2` y `mimarco`. Es posible colocarle un nombre especial a cada uno de los elementos de la lista, en este ejemplo se colocaron los nombres `E1`, `E2` y `E3` para cada uno de los tres elementos. Para observar lo que quedó almacenado en la lista se escribe `milista` en la consola y el resultado se muestra a continuación.

```{r}
milista
```

### ¿Cómo extraer elementos de una lista?
Para recuperar los elementos almacenadas en una lista se usa el operador `$`, corchetes dobles `[[]]` o corchetes sencillos `[]`. A continuación unos ejemplos para entender cómo extraer elementos de una lista.

### Ejemplos {-}
Si queremos la matriz almacenada con el nombre de `E2` dentro del objeto `milista` se puede usar el siguiente código.

```{r}
milista$E2
```

Es posible indicar la posición del objeto en lugar del nombre, para eso se usan los corchetes dobles.

```{r}
milista[[2]]
```

El resultado obtenido con `milista$E2` y `milista[[2]]` es __exactamente__ el mismo. Vamos ahora a solicitar la posición 2 pero usando corchetes sencillos.

```{r}
milista[2]
```

La apariencia de este último resultado es similar, no igual, al encontrado al usar `$` y `[[]]`. Para ver la diferencia vamos a pedir la clase a la que pertenecen los tres últimos objetos usando la función `class`. A continuación el código usado.

```{r}
class(milista$E2)
class(milista[[2]])
class(milista[2])
```

De lo anterior se observa claramente que cuando usamos `$` o `[[]]` el resultado es el objeto almacenado, una matriz. Cuando usamos `[]` el resultado es una __lista__ cuyo contenido es el objeto almacendado.

```{block2, type='rmdwarning'}
Al manipular listas con `$` y `[[]]` se obtienen los objetos ahí almacenados, al manipular listas con `[]` se obtiene una lista.
```


## EJERCICIOS {-}
Use funciones o procedimientos (varias líneas) de \proglang{R} para responder cada una de las siguientes preguntas.

1. Construya un vector con la primeras 20 letras MAYÚSCULAS usando la función LETTERS.

2. Construya una matriz de $10 \times 10$ con los primeros 100 números positivos pares.

3. Construya una matriz identidad de dimension $3 \times 3$. Recuerde que una matriz identidad tiene sólo unos en la diagonal principal y los demás elementos son cero.

4. Construya una lista con los anteriores tres objetos creados.

2. Construya un marco de datos o data frame con las respuestas de 3 personas a las preguntas: (a) ¿Cuál es su edad en años? (b) ¿Tipo de música que más le gusta? (c) ¿Tiene usted pareja sentimental estable?

3. ¿Cuál es el error al correr el siguiente código? ¿A qué se debe?

```{r, echo = TRUE, eval=F}
edad <- c(15, 19, 13, NA, 20)
deporte <- c(TRUE, TRUE, NA, FALSE, TRUE)
comic.fav <- c(NA, 'Superman', 'Batman', NA, 'Batman')
matrix(edad, deporte, comic.fav)
```



<!--chapter:end:02_objetos.Rmd-->

# Guía de estilo \index{estilo}

Así como en el español existen reglas ortográficas, la escritura de códigos en \proglang{R} también tiene unas reglas que se recomienda seguir para evitar confusiones. Tener una buena guía de estilo \index{guía de estilo} es importante para que el código creado por usted sea fácilmente entendido por sus lectores @rpackages. No existe una única y mejor guía de estilo para escritura en \proglang{R}, sin embargo aquí vamos a mostrar unas sugerencias basadas en la guía llamada \href{https://google.github.io/styleguide/Rguide.xml}{\textit{Google's R style guide}}.

## Nombres de los archivos
Se sugiere que el nombre usado para nombrar un archivo tenga sentido y que termine con extensión .R. A continuación dos ejemplos de como nombrar mal y bien un archivo.

- Bien: `hola.R`
- Mal: `analisis_icfes.R`

## Nombres de los objetos
Se recomienda no usar los símbolos `_` y `-` dentro de los nombres de objetos. Para las variables es preferible usar letras minúsculas y separar las palabras con puntos (`peso.maiz`) o utilizar la notación camello iniciando en minúscula (`pesoMaiz`). Para las funciones se recomienda usar la notación camello iniciando todas la palabras en mayúscula (`PlotRes`). Para los nombres de las constantes se recomienda que inicien con la letra k (`kPrecioBus`). A continuación ejemplos de buenas y malas prácticas.

Para variables:

\begin{itemize}
	\item Bien: \verb|avg.clicks|
	\item Aceptable: \verb|avgClicks|
	\item Mal: \verb|avg_Clicks|
\end{itemize}

Para funciones:

\begin{itemize}
	\item Bien: \verb|CalculateAvgClicks| 
	\item Mal: \verb|calculate_avg_clicks| , \verb|calculateAvgClicks|
\end{itemize}

## Longitud de una línea de código
Se recomienda que cada línea tenga como máximo 80 caracteres. Si una línea es muy larga se debe cortar siempre por una coma.

## Espacios
Use espacios alrededor de todos los operadores binarios (=, +, -, <-, etc.). Los espacios alrededor del símbolo ``='' son opcionales cuando se usan para ingresar valores dentro de una función. Así como en español, nunca coloque espacio antes de una coma, pero siempre use espacio luego de una coma. A continuación ejemplos de buenas y malas prácticas.

```{r, eval=F}
tab <- table(df[df$days < 0, 2])  # Bien
tot <- sum(x[, 1])                # Bien
tot <- sum(x[1, ])                # Bien
tab <- table(df[df$days<0, 2])    # Faltan espacios alrededor '<' 
tab <- table(df[df$days < 0,2])   # Falta espacio luego de coma
tab <- table(df[df$days < 0 , 2]) # Sobra espacio antes de coma
tab<- table(df[df$days < 0, 2])   # Falta espacio antes de '<-'
tab<-table(df[df$days < 0, 2])    # Falta espacio alrededor de '<-'
tot <- sum(x[,1])                 # Falta espacio luego de coma
tot <- sum(x[1,])                 # Falta espacio luego de coma
```

Otra buena práctica es colocar espacio antes de un paréntesis excepto cuando se llama una función.

```{r, eval=F}
if (debug)    # Correcto
if(debug)     # Funciona pero no se recomienda
colMeans (x)  # Funciona pero no se recomienda
```

Espacios extras pueden ser usados si con esto se mejora la apariencia del código, ver el ejemplo siguiente.

```{r, eval=F}
plot(x    = x.coord,
     y    = data.mat[, MakeColName(metric, ptiles[1], "roiOpt")],
     ylim = ylim,
     xlab = "dates",
     ylab = metric,
     main = (paste(metric, " for 3 samples ", sep = "")))
```

No coloque espacios alrededor del código que esté dentro de paréntesis `( )` o corchetes `[ ]`, la única excepción es luego de una coma, ver el ejemplo siguiente.

```{r, eval=F}
if (condicion)    # Correcto 
x[1, ]            # Correcto
if ( condicion )  # Sobran espacios alrededor de condicion
x[1,]             # Se necesita espacio luego de coma
```

Los signos de agrupación llaves `{ }` se utilizan para agrupar bloques de código y se recomienda que nunca una llave abierta `{` esté sola en una línea; una llave cerrada `}` si debe ir sola en su propia línea. Se pueden omitir las llaves cuando el bloque de instrucciones esté formado por una sola línea pero esa línea de código NO debe ir en la misma línea de la condición. A continuación dos ejemplos de lo que se recomienda.

```{r, eval=F}
if (is.null(ylim)) {                     # Correcto
  ylim <- c(0, 0.06)
}

if (is.null(ylim))                       # Correcto
  ylim <- c(0, 0.06)

if (is.null(ylim)) ylim <- c(0, 0.06)    # Aceptable

if (is.null(ylim))                       # No se recomienda
{        
  ylim <- c(0, 0.06)
}
	
if (is.null(ylim)) {ylim <- c(0, 0.06)}
# Frente a la llave { no debe ir nada
# la llave de cierre } debe ir sola
```

La sentencia else debe ir siempre entre llaves `} {`, ver el siguiente ejemplo.

```{r, eval=F}
if (condition) {         
  one or more lines
} else {                 # Correcto
  one or more lines
}


if (condition) {         
  one or more lines
}
else {                   # Incorrecto
  one or more lines
}


if (condition)           
  one line
else                     # Incorrecto
  one line
```

## Asignación

Para realizar asignaciones se recomienda usar el símbolo `<-`, el símbolo de igualdad `=` no se recomienda usarlo para asignaciones.

```{r, eval=F}
x <- 5  # Correcto
x = 5   # No recomendado
```

Para una explicación más detallada sobre el símbolo de asignación se recomienda visitar este [enlace](http://www.win-vector.com/blog/2016/12/the-case-for-using-in-r/).

## Punto y coma
No se recomienda colocar varias instrucciones separadas por `;` en la misma línea, aunque funciona dificulta la revisión del código.

```{r, eval=F}
n <- 100; y <- rnorm(n, mean=5); hist(y)  # No se recomienda

n <- 100                                  # Correcto
y <- rnorm(n, mean=5)
hist(y)
```
A pesar de la anterior advertencia es posible que en este libro usemos el `;` en algunas ocasiones, si lo hacemos es para ahorrar espacio en la presentación del código.




<!--chapter:end:03_estilo.Rmd-->

# Funciones básicas de \proglang{R} \label{funbas}

En este capítulo se presentará lo que es una función y se mostrarán varias funciones básicas que son útiles para realizar diversas tareas.

## ¿Qué es una función de \proglang{R}? \index{función} \index{function}
En la Figura \@ref(fig:machine) se muestra una ilustración de lo que es una función o máquina general. Hay unas entradas (_inputs_) que luego son procesadas dentro de la caja para generar unas salidas (_outputs_). Un ejemplo de una función o máquina muy común en nuestras casas es la licuadora. Si a una licuadora le ingresamos leche, fresas, azúcar y hielo, el resultado será un delicioso jugo de fresa. 

```{r machine, echo=F, fig.cap='Ilustración de una función, tomada de www.mathinsight.org.', dpi=250, fig.align='center'}
knitr::include_graphics("images/function_machine.png")
```

Las funciones en \proglang{R} se caracterizan por un nombre corto y que dé una idea de lo que hace la función. Los elementos que pueden ingresar (_inputs_) a la función se llaman __parámetros__ y se ubican dentro de paréntesis, el cuerpo de la función se ubica dentro de llaves y es ahí donde se procesan los _inputs_ para convertirlos en _outputs_, a continuación se muestra la estructura general de una función.

```{r, eval=F}
nombre_de_funcion(parametro1, parametro2, ...) {
  tareas internas
  tareas internas
  tareas internas
  salida
}
```

Cuando usamos una función sólo debemos escribir bien el nombre e ingresar correctamente los parámetros de la función, el cuerpo de la función ni lo vemos ni lo debemos modificar. A continuación se presenta un ejemplo de cómo usar la función `mean` para calcular un promedio.

```{r}
notas <- c(4.0, 1.3, 3.8, 2.0)  # Notas de un estudiante
mean(notas)
```

## Operadores de asignación \index{asignación}
En \proglang{R} se pueden hacer asignación de varias formas, a continuación se presentan los operadores disponibles para tal fin.

- `<-` este es el operador de asignación a izquierda, es el más usado y recomendado.
- `->` este es el operador de asignación a derecha, no es frecuente su uso.
- `=` el símbolo igual sirve para hacer asignaciones pero __NO__ se recomienda usarlo.
- `<<-` este es un operador de asignación global y sólo debe ser usado por usuarios avanzados.

### Ejemplo {-}
Almacene los valores 5.3, 4.6 y 25 en los objetos `a`, `b` y `age` respectivamente, use diferentes símbolos de asignación.

Para hacer lo solicitado se podría usar el siguiente código.

```{r}
a <- 5.3 # Recomended
4.6 -> b # It is not usual
age = 25 # Not recomended
```

```{block2, type='rmdimportant'}
Aunque una asignación se puede hacer de tres formas diferentes, se recomienda sólo usar el símbolo `<-`.
```

## Operaciones básicas \index{operaciones básicas}
En \proglang{R} se pueden hacer diversas operaciones usando operadores binarios. Este tipo de operadores se denomina binarios porque actuan entre dos objetos, a continuación el listado.

- `+` operador binario para sumar.
- `-` operador binario para restar.
- `*` operador binario para multiplicar.
- `/` operador binario para dividir.
- `^` operador binario para potencia.
- `%/%` operador binario para obtener el cociente en una división (número entero).
- `%%` operador binario para obtener el residuo en una división.


A continuación se presentan ejemplos de cómo usar las anteriores funciones.

```{r}
6 + 4  # Para sumar dos números
a <- c(1, 3, 2)
b <- c(2, 0, 1)  # a y b de la misma dimensión
a + b  # Para sumar los vectores a y b miembro a miembro
a - b  # Para restar dos vectores a y b miembro a miembro
a * b  # Para multiplicar
a / b  # Para dividir
a ^ b  # Para potencia
7 %/% 3  # Para saber las veces que cabe 3 en 7
7 %% 3  # Para saber el residuo al dividir 7 entre 3
```

## Pruebas lógicas \index{pruebas lógicas}
En \proglang{R} se puede verificar si un objeto cumple una condición dada, a continuación el listado de las pruebas usuales.

- `<` para saber si un número es menor que otro.
- `>` para saber si un número es mayor que otro.
- `==` para saber si un número es igual que otro.
- `<=` para saber si un número es menor o igual que otro.
- `>=` para saber si un número es mayor o igual que otro.

A continuación se presentan ejemplos de cómo usar las anteriores funciones.

```{r}
5 < 12  # ¿Será 5 menor que 12?
# Comparando objetos
x <- 5
y <- 20 / 4
x == y  # ¿Será x igual a y?
# Usando vectores
a <- c(1, 3, 2)
b <- c(2, 0, 1)
a > b  # Comparación término a término
a == b  # Comparación de igualdad término a término
```

### Ejemplo {-}
Crear un vector con los números de 1 a 17 y extrater los números que son mayores o iguales a 12.

Primero se crear el vector `x` con los elementos del 1 al 17. La prueba lógica `x >= 12` se usa para evaluar la condición, el resultado es un vector de 17 posiciones con valores de `TRUE` o `FALSE` dependiendo de si la condición se cumple o no. Este vector lógico se coloca dentro de `x[ ]` para que al evaluar `x[x >= 12]` sólo aparezcan los valores del vector original que SI cumplen la condición. El código necesario se muestra a continuación.

```{r}
x <- 1:17  # Se crea el vector
x[x >= 12]  # Se solicitan los valores que cumplen la condición
```

### Ejemplo {-}
Retome el marco de datos `mimarco` construído en la sección \@ref(marcodatos) y use una prueba lógica para extraer la información de las personas que tienen una edad superior o igual a 15 años.

Inicialmente vamos a construir nuevamente el objeto `mimarco` de la sección \@ref(marcodatos) usando el siguiente código.

```{r}
mimarco <- data.frame(edad = c(15, 19, 13, NA, 20), 
                      deporte = c(TRUE, TRUE, NA, FALSE, TRUE),
                      comic.fav = c(NA, 'Superman', 'Batman',
                                    NA, 'Batman'))

mimarco  # Para ver el contenido de mimarco
```

Para extraer de `mimarco` la información de las personas que tienen una edad superior o igual a 15 años se coloca dentro de corchetes la condición `mimarco$edad >= 15`, esto servirá para chequear cuáles de las edades del vector `mimarco$ead` cumplen la condición. El resultado de evaluar `mimarco$edad >= 15` será un vector lógico (`TRUE` o `FALSE`), que al ser colocado dentro de `mimarco[,]`, entregará la información de las personas que cumplen la condición. A continuación el código para extraer la información solicitada.

```{r}
mimarco[mimarco$edad >= 15, ]
```

De la salida anterior se observa que 4 personas de las 5 cumplean la condición.

```{block2, type='rmdwarning'}
Note que la condición `mimarco$edad >= 15` se debe ubicar __antes__ de la coma para obtener todos individuos que cumplen con la condición.
```

## Operadores lógicos \index{operadores lógicos}
En \proglang{R} están disponibles los operadores lógicos negación, conjunción y disyunción. A continuación el listado de los operadores entre los elementos `x` e `y`.

```{r, eval=F}
!x  # Negación de x
x & y  # Conjunción entre x e y
x && y
x | y  # Disyunción entre x e y
x || y
xor(x, y)
```

A continuación se presentan ejemplos de cómo usar el símbolo de negación `!`.

```{r}
ans <- c(TRUE, FALSE, TRUE)
!ans  # Negando las respuestas almacenadas en ans
x <- c(5, 1.5, 2, 3, 2)
!(x < 2.5)  # Negando los resultados de una prueba
```

A continuación se presentan ejemplos de cómo aplicar la conjunción `&` y `&&`.

```{r}
x <- c(5, 1.5, 2)  # Se construyen dos vectores para la prueba
y <- c(4, 6, 3)

x < 4  # ¿Serán los elementos de x menores que 4?
y > 5  # ¿Serán los elementos de y mayores que 5?
x < 4 & y > 5  # Conjunción entre las pruebas anteriores.
x < 4 && y > 5  # Conjunción vectorial
```

Note las diferencias entre los dos últimos ejemplos, cuando se usa `&` se hace una prueba término a término y el resultado es un vector, cuando se usa `&&` se aplica la conjunción al vector de resultados obtenido con `&`.

### Ejemplo {-}
Retome el marco de datos `mimarco` construído en la sección \@ref(marcodatos) y use una prueba lógica para extraer la información de las personas que tienen una edad superior o igual a 15 años y que practican deporte.

Aquí interesa extraer la información de los individuos que cumplen dos condiciones simultáneamente, aquellos con edad $\geq$ 15 y que SI practiquen deporte. El código necesario para obtener la información solicitada es el siguiente.

```{r}
mimarco[mimarco$edad >= 15 & mimarco$deporte == TRUE, ]
```

De la anterior salida se observa que sólo 3 de las 5 personas cumplen ambas condiciones.

\index{with}
```{block2, type='rmdtip'}
La función `with` es útil porque nos permite realizar algún procedimiento __CON__ un objeto, escribiendo menos y de una forma más natural.
```

Una forma alternativa para escribir lo anterior usando la función `with` es la siguiente.

```{r}
with(mimarco, mimarco[edad >= 15 & deporte == TRUE, ])
```

Al usar `with` sólo se tuvo que escribir el objeto `mimarco` dos veces. Cuando hay muchas condiciones o cuando el objeto tiene un nombre largo es aconsejable usar `with`.

## Funciones sobre vectores
En \proglang{R} podemos destacar las siguientes funciones básicas sobre vectores numéricos.

\index{min} \index{max} \index{legth} \index{range} \index{sum} \index{prod} \index{which.min} \index{which.max}  

- `min`: para obtener el mínimo de un vector.
- `max`: para obtener el máximo de un vector.
- `length`: para determinar la longitud de un vector.
- `range`: para obtener el rango de valores de un vector, entrega el mínimo y máximo.
- `sum`: entrega la suma de todos los elementos del vector.
- `prod`: multiplica todos los elementos del vector.
- `which.min`: nos entrega la posición en donde está el valor mínimo del vector.
- `which.max`: nos da la posición del valor máximo del vector.
- `rev`: invierte un vector.

### Ejemplo {-}
Construir en vector llamado `myvec` con los siguientes elementos: 5, 3, 2, 1, 2, 0, NA, 0, 9, 6. Luego aplicar todas las funciones anteriores para verificar el funcionamiento de las mismas.

```{r}
myvec <- c(5, 3, 2, 1, 2, 0, NA, 0, 9, 6)
myvec

min(myvec)  # Opss, no aparece el mínimo que es Cero.
min(myvec, na.rm=TRUE)  # Usamos na.rm = TRUE para remover el NA
max(myvec, na.rm=T)  # Para obtener el valor máximo
range(myvec, na.rm=T)  # Genera min y max simultáneamente
sum(myvec, na.rm=T)  # La suma de los valores internos
prod(myvec, na.rm=T)  # El productor de los valores internos
which.min(myvec)  # Posición del valor mínimo 0 en el vector
which.max(myvec)  # Posición del valor máximo 9 en el vector
```

De las dos últimas líneas podemos destacar lo siguiente:

1. __NO es necesario__ usar `na.rm = TRUE` para remover el `NA` dentro de las funciones `which.min` ni `which.max`.
2. El valor mínimo 0 aparece en las posiciones 6 y 8 pero la función `which.min` sólo entrega la posición del primer valor mínimo dentro del vector.

## Funciones matemáticas
Otras funciones básicas muy utilizadas en estadística son: `sin, cos, tan, asin, acos, atan, atan2, log, logb, log10, exp, sqrt, abs`. A continuación algunos ejemplos de las anteriores funciones.

__Ejemplos de medidas trigonométricas__
```{r}
angulos <- c(0, pi/2, pi)
sin(angulos)
tan(angulos)
```

__Ejemplos de logaritmos__
```{r}
log(100)
log10(100)
logb(125, base=5)
```

__Ejemplos de exponencial__
```{r}
exp(1)
exp(2)
exp(1:3)
```

__Ejemplos de raices__
```{r}
sqrt(49)  # Raiz cuadrada de 49
27 ^ (1/3)  # Raiz cúbica de 27
```

__Ejemplos de valor absoluto__
```{r}
abs(2.5)
abs(-3.6)
```

## Función `seq` \index{seq} \index{secuencias}
En \proglang{R} podemos crear secuencias de números de una forma sencilla usando la función `seq`, la estructura de esta función es:

```{r, eval=F}
seq(from=1, to=1, by, length.out)
```

Los argumentos de esta función son:

- `from`: valor de inicio de la secuencia.
- `to`: valor de fin de la secuencia, no siempre se alcanza.
- `by`: incremento de la secuencia.
- `length.out`: longitud deseado de la secuencia.

### Ejemplo {-}
Construya las siguientes tres secuencias usando la función `seq`.

- Once valores igualmente espaciados desde 0 hasta 1.
- Una secuencia de dos en dos comenzando en 1.
- Una secuencia desde 1 con un salto de $\pi$ y sin pasar del número 9.

El código necesario para obtener las secuencias se muestra a continuación.

```{r}
seq(from=0, to=1, length.out = 11)
seq(from=1, to=9, by=2)  # matches 'end'
seq(from=1, to=9, by=pi) # stays below 'end'
```

```{block2, type='rmdnote'}
En \proglang{R} existe el operador binario `:` que sirve para construir secuencias de uno en uno fácilmente.
```

Revise los siguientes ejemplos para entender el funcionamiento del operador `:`.

```{r}
2:8
3:-5
pi:6  # real sequence
6:pi  # integer sequence
```

## Función `rep` \index{rep} \index{repeticiones}
En \proglang{R} podemos crear repeticiones usando la función `rep`, la estructura de esta función es:

```{r, eval=F}
rep(x, times=1, length.out=NA, each=1)
```

Los argumentos de esta función son:

- `x`: vector con los elementos a repetir.
- `times`: número de veces que el vector `x` se debe repetir.
- `length.out`: longitud deseada para el vector resultante.
- `each`: número de veces que cada elemento de `x` se debe repetir.

### Ejemplo {-}
Construya las siguientes repeticiones usando la función `rep`, no lo haga ingresando número por número.

- 1 2 3 4 1 2 3 4
- 1 1 2 2 3 3 4 4
- 1 1 2 3 3 4
- 1 1 2 2 3 3 4 4

La clave para construir una repetición es descrubir la semilla o elemento que se repite. Las instrucciones para obtener las repeticiones anteriores se muestra a continuación.

```{r}
rep(x=1:4, times=2)
rep(x=1:4, times=c(2,2,2,2))
rep(x=1:4, times=c(2,1,2,1))
rep(x=1:4, each=2)
```

### Ejemplo {-}
La función `rep` es muy versátil, observe los siguientes 4 ejemplos y saque una conclusión de cada uno de ellos.

```{r}
rep(x=1:4, each=2)
rep(x=1:4, each=2, len=4)    # first 4 only.
rep(x=1:4, each=2, len=10)   # 8 integers plus two recycled 1's.
rep(x=1:4, each=2, times=3)  # length 24, 3 complete replications
```

## Funciones `round`, `ceiling`, `floor` y `trunc` \index{round} \index{ceiling}  \index{floor}  \index{trunc}

Existen 4 funciones útiles para modificar u obtener información de un número, estas funciones son `round`, `ceiling`, `floor` y `trunc`.

- `round(x, digits)`: sirve para redondear un número según los dígitos indicados.
- `ceiling(x)`: entrega el mínimo entero mayor o igual que `x`.
- `floor(x)`: entrega el máximo entero menor o igual que `x`.
- `trunc(x)`: entrega la parte entera de un número `x`.

### Ejemplo {-}
Aplique las funciones `round`, `ceiling`, `floor` y `trunc` a un valor positivo y a un valor negativo para inspeccionar los resultados.

A continuación el código de prueba para un número positivo cualquiera.

```{r}
x <- 5.34896  # Número positivo elegido
round(x, digits=3)
ceiling(x)
floor(x)
trunc(x)
```

A continuación las pruebas con un número negativo cualquiera.

```{r}
x <- -4.26589  # Número negativo elegido
round(x, digits=3)
ceiling(x)
floor(x)
trunc(x)
```

## Funciones `sort` y `rank` \index{sort} \index{rank}  \index{ordenar}  \index{posición}
Las funciones `sort` y `rank` son útiles para ordenar los elementos de un vector o para saber las posiciones que ocuarían los elementos de un vector al ser ordenado. La estructura de las dos funciones es la siguiente.

```{r, eval=F}
sort(x, decreasing = FALSE)
rank(x)
```

En el parámetro `x` se ingresa el vector y el parámetro `decreasing` sirva para indicar si el ordenamiento es de menor a mayor (por defecto es este) o de mayor a menor.

### Ejemplo {-}
Considere el vector `x` que tiene los siguientes elementos: 2, 3, 6, 4, 9 y 5. Ordene el vector de menor a mayor, de mayor a menor y por último encuentre la posición que ocupan los elementos de `x` si se ordenaran de menor a mayor.

```{r}
x <- c(2, 3, 6, 4, 9, 5)
sort(x)
sort(x, decreasing=TRUE)
rank(x)
```




## EJERCICIOS {-}
Use funciones o procedimientos (varias líneas) de \proglang{R} para responder cada una de las siguientes preguntas.


1. ¿Qué cantidad de dinero sobra al repartir 10000\$ entre 3 personas?
2. ¿Es el número 4560 divisible por 3?
3. Construya un vector con los números enteros del 2 al 87. ¿Cuáles de esos números son divisibles por 7?
4. Construya dos vectores, el primero con los números enteros desde 7 hasta 3, el segundo vector con los primeros cinco números positivos divisibles por 5. Sea A la condición de ser par en el primer vector. Sea B la condición de ser mayor que 10 en el segundo vector. ¿En cuál de las 5 posiciones se cumple A y B simultáneamente?
5. Consulte el siguiente enlace sobre una anéctoda de Gauss cuando tenía 10 años de edad http://tinyurl.com/hk2l8h2. Use R para obtener el resultado de la suma solicitada por el profesor del niño Gauss.
6. Construya un vector con los siguientes elementos: 1, -4, 5, 9, -4. Escriba un procedimiento para extraer __las posiciones__ donde está el valor mínimo en el vector.
7. Calcular $8!$
8. Evaluar la siguiente suma $\sum_{i=3}^{i=7}e^i$
9. Evaluar la siguiente productoria $\prod_{i=1}^{i=10}\log\sqrt{i}$
10. Construya un vector cualquiera e inviertalo, es decir, que el primer elemento quede de último, el segundo de penúltimo y así sucesivamente. Compare su resultado con el de la función `rev`.
11. Create the vector: $1, 2, 3, \ldots, 19, 20$.
12. Create the vector: $20, 19, \ldots , 2, 1$.
13. Create the vector: $1, -2, 3, -4, 5, -6, \ldots, 19, -20$.
14. Create the vector: $0.1^3, 0.2^1, 0.1^6, 0.2^4, . . . , 0.1^{36}, 0.2^{34}$.
15. Calculate the following: $\sum_{i=10}^{100}(i^3+4i^2)$ and $\sum_{i=1}^{25}\left( \frac{2^i}{i} + \frac{3^i}{i^2} \right)$.
16. Read the data set available in: http://tinyurl.com/hcusrdc
17. Use a code to obtain the number of variables of the data set.
18. Use a code to obtain the number of countries in the data set.
19. Which is the country with the higher population?
20. Which is the country with the lowest literacy rate?
21. ¿Qué valor de verdad tiene la siguiente afirmación? "Los resultados de la función `floor` y `trunc` son siempre los mismos".

En \proglang{R} hay unas bases de datos incluídas, una de ellas es la base de datos llamada `mtcars`. Para conocer las variables que están en `mtcars` usted puede escribir en la consola `?mtcars` o también `help(mtcars)`. De la base `mtcars` obtenga bases de datos que cumplan las siguientes condiciones.

22. Autos que tengan un rendimiento menor a 18 millas por galón de combustible.
23. Autos que tengan 4 cilindros.
24. Autos que pesen más de 2500 libras y tengan transmisión manual.




















<!--chapter:end:04_Fun_Bas.Rmd-->

# Creación de funciones en \proglang{R}

En este capítulo se explica cómo crear una función en \proglang{R}.

## Función en \proglang{R} \index{función}
En el Capítulo \@ref(funbas) se dió una explicación de lo que es una función de \proglang{R}, se dijo que una función es un conjunto de instrucciones que convierten unas entradas (_inputs_) en resultados (_outputs_) deseados.

## Partes de una función en \proglang{R} \index{partes de función}
Las partes de una función son:

- Entradas: o llamadas también __argumentos__, sirven para ingresar información necesaria para realizar el procedimiento de la función. Los argumentos pueden estar vacíos y a la espera de que el usuario ingrese valores, o pueden tener valores por defecto, esto significa que si el usuario no ingresa una valor al función usará el valor por defecto. Una función puede tener o no argumentos de entrada, en los ejemplos se mostrarán estos casos.
- Cuerpo: el cuerpo de la función está formado por un conjunto de instrucciones que transforman las entradas en las salidas deseadas. Si el cuerpo de la función está formado por varias instrucciones éstas deben ir entre llaves.
- Salidas: son los resultados de la función. Toda función debe tener al menos un resultado, si una función no genera un resultado entonces no sirve para nada. Si una función entrega varios tipos de objetos se acostumbra a organizarlos en una lista que puede manejar los diferentes tipos de objetos.

A continuación se mostrarán varios ejemplos __sencillos__ para que el lector aprenda a construir funciones.

### Ejemplo {-}
Construir una función que reciba dos números y que entregue la suma de estos números.

Lo primero es elegir un nombre apropiado para la función, aquí se usó el nombre `suma` porque así se tiene una idea clara de lo que hace la función. La función suma recibe dos parámetros, `x` representa el primer valor ingresado mientras que `y` representa el segundo. El cuerpo de la función está formado por dos líneas, en la primera se crea el objeto `resultado` en el cual se almanacena el valor de la suma, en la segunda línea se le indica a \proglang{R} que queremos que retorne el valor de la suma almacenada en el objeto `resultado`. A continuación se muestra el código para crear la función solicitada.

```{r}
suma <- function(x, y) {
  resultado <- x + y
  return(resultado)
}
```

Para usar la función creada sólo se debe ejecutar, vamos a obtener la suma de los valores 4 y 6 usando la función `suma`, a continuación el código necesario.

```{r}
suma(x=4, y=6)
```

Para funciones simples como la anterior es posible escribirlas en forma más compacta. Es posible reducir el cuerpo de la función de 2 líneas a sólo una línea solicitándole a \proglang{R} que retorne directamente la suma sin almacenarla en ningún objeto. A continuación la función `suma` modificada.

```{r}
suma <- function(x, y) {
  return(x + y)
}

suma(x=4, y=6)  # Probando la función
```

Debido a que la función `suma` tiene un cuerpo muy reducido es posible escribirla en forma más compacta, en una sola línea. A continuación se muestra el código para reescribir la función.

```{r}
suma <- function(x, y) x + y

suma(x=4, y=6)  # Probando la función
```

### Ejemplo {-}
Construir una función que genere números aleatorios entre cero y uno hasta que la suma de éstos números supere por primera vez el valor de 3. La función debe entregar la cantidad de números aleatorios generados para que se cumpla la condición.

Vamos a llamar la función solicitada con el nombre `fun1`, esta función __NO__ necesita ningún parámetro de entrada. El valor de 3 que está en la condición puede ir dentro del cuerpo y por eso no se necesitan parámetros para esta función. En el cuerpo de la función se genera un vector con un número aleatorio y luego se chequea si la suma de sus elementos es menor de 3, si se cumple que la suma es menor que 3 se siguen generando números que se almacenan en el vector `num`. Una vez que la suma exceda el valor de 3 NO se ingresa al `while` y se pide la longitud del vector o el valor de `veces` solicitado. A continuación el código de la función.

```{r}
fun1 <- function() {
  num <- runif(1)
  veces <- 1
  while (sum(num) < 3) {
    veces <- veces + 1
    num[veces] <- runif(1)
  }
  return(veces)
}

fun1()  # primera prueba
```

### Ejemplo {-}
Construir una función que, dado un número entero positivo (cota) ingresado por el usuario, genere números aleatorios entre cero y uno hasta que la suma de los números generados exceda por primera vez la cota. La función debe entregar un vector con los números aleatorios, la suma y la cantidad de números aleatorios. Si el usuario no ingresa el valor de la cota, se debe asumir igual a 1.

La función aquí solicitada es similar a la construída en el ejemplo anterior. La función `fun2` tiene un sólo parámetro con el valor por defecto, si el usuario no ingresa valor a este parámetro, se asumirá el valor de uno. El cuerpo de la función es similar al anterior. Como la función debe entregar un vector y dos números, se construye la lista `resultado` que almacena los tres objetos solicitados. A continuación el código para función solicitada.

```{r}
fun2 <- function(cota=1) {
  num <- runif(1)
  while (sum(num) < cota) {
    num <- c(num, runif(1))
  }
  resultado <- list(vector=num,
                    suma=sum(num),
                    cantidad=length(num))
  return(resultado)
}
```

Probando la función con cota de uno.

```{r}
fun2()
```

Probando la función con cota de tres.

```{r}
fun2(cota=3)
```

### Ejemplo {-} 
Construya una función que reciba dos números de la recta real y que entregue el punto médio de estos números. El resultado debe ser un mensaje por pantalla.

El punto médio entre dos valores es la suma de los números divido entre dos. La función `cat` sirve para concatenar objetos y presentarlos por pantalla. A continuación el código para la función requerida.

```{r}
medio <- function(a, b) {
  medio <- (a + b) / 2
  cat("El punto medio de los valores",
      a, "y", b,
      "ingresados es", medio)
}

medio(a=-3, b=-1)  # Probando la función
```

```{block2, type='rmdnote'}
La función `cat` es muy útil para presentar resultados por pantalla. Consulte la ayuda de la función para ver otros ejemplos.
```

## EJERCICIOS {-}
Construir funciones en \proglang{R} que realicen lo solicitado.

1. Construya una función que reciba dos números reales y que diga cuál es el mayor de ellos.

2. Escriba una función llamada media que calcule la media muestral de un vector numérico ingresado a la función. A continuación la fórmula para calcular la media muestral.

$$\bar{x}=\frac{\sum_{i=1}^n x_i}{n}$$
Verifique el desempeño de su función comparando con la función `mean`. Corra el siguiente código para hacer la prueba, los resultados deben coincidir.
```{r, eval=F}
x <- runif(n=100)
media(x)
mean(x)
```

3. Construya una función que encuentre las raíces de una ecuación de segundo grado. El usuario debe suministrar los coeficientes `a`, `b` y `c` de la ecuación $ax^2+bx+c=0$ y la función debe entregar las raíces.

4. Escribir una función que calcule la velocidad de un proyectil dado que el usuario ingresa la distancia  Km y el tiempo  en minutos. Expresar el resultado en metros/segundo, recuerde que $velocidad = espacio / tiempo$.




<!--chapter:end:05_Cre_Fun.Rmd-->

# Lectura de bases de datos \index{lectura de bases de datos}

En este capítulo se mostrará cómo leer una base de datos externa hacia \proglang{R}.

## ¿En qué formato almacenar una base de datos? \index{.csv} \index{.txt}
Usualmente los archivos con la información para ser leídos por \proglang{R} se pueden almacenar en formato:

- plano con extensión __.txt__ o, 
- Excel con extensión __.csv__. 

En las secciones siguientes se mostrará cómo almacenar datos en los dos formatos para ser leídos en \proglang{R}. En el Cuadro \@ref(tab:dt1) se presenta una base de datos pequeña, tres observaciones y tres variables, que nos servirá como ejemplo para mostrar cómo se debe almacenar la información.

```{r dt1, echo=F}
Edad <- c(35, 46, 23)
Fuma <- c(TRUE, TRUE, FALSE)
Pais <- c('Colombia', 'Francia', 'Malta')
dt <- data.frame(Edad, Fuma, Pais)
knitr::kable(dt, booktabs = TRUE,
caption = 'Ejemplo de una base de datos simple.'
)
```

### Almacenamiento de información en Excel \index{Excel}
Para almacenar la información del Cuadro \@ref(tab:dt1) en Excel, abrimos un archivo nuevo archivo de Excel y copiamos la información tal como se muestra en la Figura \@ref(fig:excel1). Se debe iniciar en la parte superior izquierda, no se deben dejar filas vacías, no se debe colorear, no se deben colocar bordes ni nada, se ingresa la información sin embellecer el contenido. Por último se guarda el archivo en la carpeta deseada y al momento de nombrar el archivo se debe modificar la opción tipo de archivo a __csv (delimitado por comas)__.

```{r excel1, echo=F, fig.cap='Forma de almacenar los datos en Excel.', dpi=300, fig.align='center'}
knitr::include_graphics("images/excel1.png")
```

```{block2, type='rmdwarning'}
Recuerde que el archivo de Excel se debe guardar con extensión .csv.
```

### Almacenamiento de información en bloc de notas \index{bloc de notas}
Para almacenar la información del Cuadro \@ref(tab:dt1) en bloc de notas, abrimos un archivo nuevo de bloc de notas y copiamos la información tal como se muestra en la Figura \@ref(fig:bloc1). Se copian los nombres de las variables o los datos separados por un espacio obtenido con la tecla tabuladora, cada línea se finaliza con un _enter_. Se recomienda al guardar el archivo que el cursor al inicio de una línea vacía, en la Figura \@ref(fig:bloc1) se señala la posición del cursor con la flecha roja, a pesar de que no éxiste línea número 5, el curso debe quedar al inicio de esa línea número 5.

```{r bloc1, echo=F, fig.cap='Almacenamiento de los datos en bloc de notas usando la barra espaciadora', dpi=110, fig.align='center'}
knitr::include_graphics("images/bloc1.png")
```

Es posible mejorar la apariencia de la información almacenada en el bloc de notas si, en lugar de usar espacios con la barra espaciadora, se colocan los espacios con la barra tabuladora, así la información se ve más organizada y se puede chequear fácilmente la información ingresada. En la Figura \@ref(fig:bloc2) se muestra la información para el ejemplo, claramente se nota la organización de la información.

```{r bloc2, echo=F, fig.cap='Almacenamiento de los datos en bloc de notas usando la barra tabuladora', dpi=110, fig.align='center'}
knitr::include_graphics("images/bloc2.png")
```

```{block2, type='rmdtip'}
Una buena práctica es usar la barra tabuladora para separar, eso permite que la información se vea ordenada.
```

## Función `read.table` \index{read.table}
La función `read.table` se puede usar para leer bases de datos hacia \proglang{R}. La estructura de la función con los parámetros más comunes de uso es la siguiente.

```{r, eval=F}
read.table(file, header, sep, dec)
```

Los argumentos de la función `read.table` son:

- `file`: nombre o ruta donde están alojados los datos. Puede ser un url o una dirección del computador. Es también posible usar `file.choose()` para que se abra un ventana y adjuntar el archivo deseado manualmente.
- `header`: valor lógico, se usa `TRUE` si la primera línea de la base de datos tiene los nombres de las variables, caso contrario se usa `FALSE`.
- `sep`: tipo de separación interna para los datos dentro del archivo. Los valores usuales para este parámetros son:
    - `sep=','` si el archivo tiene extensión .csv. 
    - `sep=''` si el archivo es bloc de notas con espacios por la barra __espaciadora__. 
    - `sep='\t'` si el archivo es bloc de notas con espacios por la barra __tabuladora__. 
- `dec`: símbolo con el cual están indicados los decimales.

### Ejemplo {-}
Crear la base de datos del Cuadro \@ref(tab:dt1) en Excel y bloc de notas para practicar la lectura de base de datos desde \proglang{R}.

Lo primero que se debe hacer para realizar lo solicitado es construir tres archivos (uno de Excel y dos bloc de notas) igual a los mostrados en las figuras \@ref(fig:excel1), \@ref(fig:bloc1) y \@ref(fig:bloc2), vamos a suponer que los nombres para cada uno de ellos son `base1.csv`, `base2.txt` y `base3.txt` respectivamente.

#### Para Excel {-}

Para leer el archivo de Excel llamado `base1.csv` podemos usar el siguiente código.

```{r, eval=F}
datos <- read.table(file='C:/Users/Hernandez/Desktop/base1.csv',
                    header=TRUE, sep=',')
datos
```

La dirección `file='C:/Users/Hernandez/Desktop/base1.csv'` le indica a \proglang{R} en qué lugar del computador debe buscar el archivo, note que se debe usar el símbolo `/` para que sea un dirección válida. Substituya la dirección del código anterior con la dirección donde se encuentra su archivo para que pueda leer la base de datos.

Si no se conoce la ubicación del archivo a leer o si la dirección es muy extensa, se puede usar `file.choose()` para que se abra una ventana y así adjuntar manualmente el archivo. A continuación se muestra el código para hacerlo de esta manera.

```{r, eval=F}
datos <- read.table(file.choose(), header=TRUE, sep=',')
datos
```

#### Para bloc de notas con barra espaciadora {-}

Para leer el archivo de Excel llamado `base2.txt` podemos usar el siguiente código.

```{r, eval=F}
datos <- read.table(file='C:/Users/Hernandez/Desktop/base2.txt',
                    header=TRUE, sep='')
datos
```

#### Para bloc de notas con barra tabuladora {-}

Para leer el archivo de Excel llamado `base3.txt` podemos usar el siguiente código.

```{r, eval=F}
datos <- read.table(file='C:/Users/Hernandez/Desktop/base3.txt',
                    header=TRUE, sep='\t')
datos
```

```{block2, type='rmdnote'}
El usuario puede usar indiferentemente `file='C:/Users/bla/bla'` o `file.choose()` para ingresar el archivo, con la práctica se aprende a decidir cuando conviene una u otra forma. 
```

```{block2, type='rmdwarning'}
Un error frecuente es escribir la dirección o ubicación del archivo usando `\`, lo correcto es usar `/`.
```

### Ejemplo {-}
Leer la base de datos sobre apartamentos usados en la ciudad de Medellín que está disponible en la página web cuya url es: https://raw.githubusercontent.com/fhernanb/datos/master/aptos2015

Para leer la base de datos desde una url usamos el siguiente código.

```{r}
enlace <- 'https://raw.githubusercontent.com/fhernanb/datos/master/aptos2015'
datos <- read.table(file=enlace, header=TRUE)
```

La base de datos ingresada queda en el marco de datos llamado `datos` y ya está disponible para usarla.

## Lectura de bases de datos en Excel
Algunas veces los datos están disponibles en un archivo estándar de Excel, y dentro de cada archivo hojas con la información a utilizar. En estos casos se recomienda usar el paquete **readxl**\index{readxl} [@R-readxl] y en particular la función `readxl`. A continuación un ejemplo de cómo proceder en estos casos.

### Ejemplo {-}
En este [enlace](https://github.com/fhernanb/datos/blob/master/BD_Excel.xlsx) está disponible un archivo de Excel llamado BD_Excel.xlxs, una vez se ha abierto la página donde está alojado el archivo, se debe descargar y guardar en alguna carpeta. El archivo contiene dos bases de datos muy pequeñas, en la primera hoja llamada __Hijos__ está la información de un grupo de niños y en la segunda hoja llamada __Padres__ está la información de los padres. ¿Cómo se pueden leer las dos bases de datos?

Lo primero que se debe hacer es instalar el paquete **readxl**, la instalación de cualquier paquete en un computador se hace una sola vez y éste quedará instalado para ser usado las veces que se requiera. La función para instalar un paquete cualquiera es `install.packages`, a continuación se muestra el código necesario para instalar el paquete **readxl**.

```{r, eval=FALSE}
install.packages("readxl")
```

Una vez instalado el paquete es necesario cargarlo, la función para cargar el paquete en la sesión actual de \proglang{R} es `library`. La instrucción para cargar el paquete es la siguiente:

```{r}
library(readxl)
```

```{block2, type='rmdwarning'}
La instalación de un paquete con `install.packages` se hace sólo una vez y no más. Cargar el paquete con `library` en la sesión actual se debe hacer siempre que se vaya a usar el paquete.
```

Luego de haber cargado el paquete **readxl** se puede usar la función `readxl` para leer la información contenida en las hojas. A continuación el código para crear la base de datos `hijos` contenida en el archivo BD_Excel.xlsx.

```{r, eval=F}
hijos <- read_excel(file.choose(), sheet='Hijos')
hijos  # Para ver el contenido
```

```{r, echo=FALSE}
hijos <- read_excel('BD_Excel.xlsx', sheet='Hijos')
hijos # Para ver el contenido
```

A continuación el código para crear la base de datos `padres` contenida en el archivo BD_Excel.xlsx.

```{r, eval=F}
padres <- read_excel('BD_Excel.xlsx', sheet='Padres')
padres  # Para ver el contenido
```

```{r, echo=FALSE}
padres <- read_excel('BD_Excel.xlsx', sheet='Padres')
padres  # Para ver el contenido
```

La función `readxl` tiene otros parámetros adicionales útiles para leer bases de datos, se recomienda consultar la ayuda de la función escribiendo en la consola `help(read.xl)`.


## EJERCICIOS {-}
Realice los siguiente ejercicios propuestos.

1. En el Cuadro \@ref(tab:toy) se presenta una base de datos sencilla. Almacene la información del cuadro en dos archivos diferentes, en Excel y en bloc de notas. Lea los dos archivos con la función `read.table` y compare los resultados obtenidos con la del Cuadro \@ref(tab:toy) fuente.

```{r toy, echo=F}
Fuma <- c('Si', 'Si', 'No', 'No', 'Si', 'No', 'Si', NA, 'Si')
Pasatiempo <- c('Lectura', NA, 'Correr', 'Correr', 'TV', 'TV', 'Correr', 'Correr', 'Lectura')
Num_hermanos <- c(0, 2, 4, NA, 3, 1, 1, 0, 2)
Mesada <- c(4500, 2600, 1000, 3990, 2570, 2371, 1389, 4589, NA)

datos <- data.frame(Fuma, Pasatiempo, Num_hermanos, Mesada)
knitr::kable(
datos, booktabs = TRUE,
caption = 'Base de datos para practicar lectura.'
)
```

2. En la url https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo están disponibles los datos sobre medidas corporales para un grupo de estudiante de la universidad, use la función `read.table` para leer la base de datos.



<!--chapter:end:06_read.Rmd-->

# Tablas de frecuencia \index{tablas de frecuencia}

Las tablas de frecuencia son muy utilizadas en estadística y \proglang{R} permite crear tablas de una forma sencilla. En este capítulo se explican las principales funciones para la elaboración de tablas.

## Tabla de contingencia con `table` \index{table}
La función `table` sirve para construir tablas de frecuencia de una vía, a continuación la estrctura de la función.

```{r, eval=F}
table(..., exclude, useNA)
```
Los parámetros de la función son:

- `...` espacio para ubicar los nombres de los objetos (variables o vectores) para los cuales se quiere construir la tabla.
- `exclude`: vector con los niveles a remover de la tabla. Si `exclude=NULL` implica que se desean ver los `NA`, lo que equivale a `useNA = 'always'`.
- `useNA`: instrucción de lo que se desea con los `NA`. Hay tres posibles valores para este parámetro: `'no'` si no se desean usar, `'ifany'` y `'always'` si se desean incluir.


### Ejemplo: tabla de frecuencia de una vía {-}
Considere el vector `fuma` mostrado a continuación y construya una tabla de frecuencias absolutas para los niveles de la variable frecuencia de fumar.

```{r}
fuma <- c('Frecuente', 'Nunca', 'A veces', 'A veces', 'A veces',
          'Nunca', 'Frecuente', NA, 'Frecuente', NA, 'hola', 
          'Nunca', 'Hola', 'Frecuente', 'Nunca')
```

A continuación se muestra el código para crear la tabla de frecuencias para la variable `fuma`.

```{r}
table(fuma)
```

De la tabla anterior vemos que NO aparece el conteo de los `NA`, para obtenerlo usamos lo siguiente.

```{r}
table(fuma, useNA='always')
```

Vemos que hay dos niveles errados en la tabla anterior, `Hola` y `hola`. Para construir la tabla sin esos niveles errados usamos lo siguiente.

```{r}
table(fuma, exclude=c('Hola', 'hola'))
```

Por último construyamos la tabla sin los niveles errados y los `NA`, a esta última tabla la llamaremos `tabla1` para luego poder usarla. Las instrucciones para hacer esto son las siguientes.

```{r}
tabla1 <- table(fuma, exclude=c('Hola', 'hola', NA))
tabla1
```

```{block2, type='rmdnote'}
Al crear una tabla con la instrucción `table(var1, var2)`, la variable 1 quedará por filas mientras que la variable 2 estará en las columnas.
```

### Ejemplo: tabla de frecuencia de dos vías {-}
Considere otro vector `sexo` mostrado a continuación y construya una tabla de frecuencias absolutas para ver cómo se relaciona el sexo con fumar del ejemplo anterior.

```{r}
sexo <- c('Hombre', 'Hombre', 'Hombre', NA, 'Mujer',
          'Casa', 'Mujer', 'Mujer', 'Mujer', 'Hombre', 'Mujer', 
          'Hombre', NA, 'Mujer', 'Mujer')
```

Para construir la tabla solicitada usamos el siguiente código.

```{r}
table(sexo, fuma)
```

De la tabla anterior vemos que aparecen niveles errados en fuma y en sexo, para retirarlos usamos el siguiente código incluyendo en el parámetro `exclude` un vector con los niveles que __NO__ deseamos en la tabla.

```{r}
tabla2 <- table(sexo, fuma, exclude=c('Hola', 'hola', 'Casa', NA))
tabla2
```

## Función `prop.table` \index{prop.table}
La función `prop.table` se utiliza para crear tablas de frecuencia relativa a partir de tablas de frecuencia absoluta, la estructura de la función se muestra a continuación.

```{r, eval=F}
prop.table(x, margin=NULL)
```

- `x`: tabla de frecuencia.
- `margin`: valor de 1 si se desean proporciones por filas, 2 si se desean por columnas, `NULL` si se desean frecuencias globales.

### Ejemplo: tabla de frecuencia relativa de una vía {-}
Obtener la tabla de frencuencia relativa para la `tabla1`.

Para obtener la tabla solicitada se usa el siguiente código.

```{r}
prop.table(x=tabla1)
```

### Ejemplo: tabla de frecuencia relativa de dos vías {-}
Obtener la tabla de frencuencia relativa para la `tabla2`.

Si se desea la tabla de frecuencias relativas global se usa el siguiente código. El resultado se almacena en el objeto `tabla3` para ser usado luego.

```{r}
tabla3 <- prop.table(x=tabla2)
tabla3
```

Si se desea la tabla de frecuencias relativas marginal por __columnas__ se usa el siguiente código.

```{r}
tabla4 <- prop.table(x=tabla2, margin=2)
tabla4
```

## Función `addmargins` \index{addmargins}
Esta función se puede utilizar para agregar los totales por filas o por columnas a una tabla de frecuencia absoluta o relativa. La estructura de la función es la siguiente.

```{r, eval=F}
addmargins(A, margin)
```

- `A`: tabla de frecuencia.
- `margin`: valor de 1 si se desean proporciones por columnas, 2 si se desean por filas, `NULL` si se desean frecuencias globales.

### Ejemplo {-}
Obtener las tablas `tabla3` y `tabla4` con los totales margines global y por columnas respectivamente.

Para hacer lo solicitado usamos las siguientes instrucciones.

```{r}
addmargins(tabla3)
addmargins(tabla4, margin=1)
```

```{block2, type='rmdwarning'}
Note que los valores de 1 y 2 en el parámetro `margin` de las funciones `prop.table` y `addmargins` significan lo contrario.
```

## Función `hist` \index{hist}
Construir tablas de frecuencias para variables cuantitativas es necesario en muchos procedimientos estadísticos, la función `hist` sirve para obtener este tipo de tablas. La estructura de la función es la siguiente.

```{r, eval=F}
hist(x, breaks='Sturges', include.lowest=TRUE, right=TRUE, 
     plot=FALSE)
```

Los parámetros de la función son:

- `x`: vector numérico.
- `breaks`: vector con los límites de los intervalos. Si no se especifica se usar la regla de Sturges para definir el número de intervalos y el ancho.
- `include.lowest`: valor lógico, si `TRUE` una observación $x_i$ que coincida con un límite de intervalo será ubicada en el intervalo izquierdo, si `FALSE` será incluída en el intervalo a la derecha.
- `right`: valor lógico, si `TRUE` los intervalos serán cerrados a derecha de la forma $(lim_{inf}, lim_{sup}]$, si es `FALSE` serán abiertos a derecha.
- `plot`: valor lógico, si `FALSE` sólo se obtiene la tabla de frecuencias mientras que con `TRUE` se obtiene la representación gráfica llamada histograma.

### Ejemplo {-}
Genere 200 observaciones aleatorias de una distribución normal con media $\mu=170$ y desviación $\sigma=5$, luego construya una tabla de frecuencias para la muestra obtenida usando (a) la regla de Sturges y (b) tres intervalos con límites 150, 170, 180 y 190.

Primero se construye el vector `x` con las observaciones de la distribución normal por medio de la función `rnorm` y se especifica la media y desviación solicitada. Luego se aplica la función `hist` con el parámetro `breaks='Sturges'`, a continuación el código utilizado.

```{r}
x <- rnorm(n=200, mean=170, sd=5)

res1 <- hist(x=x, breaks='Sturges', plot=FALSE)
res1
```

El objeto `res1` es una lista donde se encuentra la información de la tabla de frecuencias para `x`. Esa lista tiene en el elemento `breaks` los límites inferior y superior de los intervalos y en el elemento `counts` están las frecuencias de cada uno de los intervalos. 

Para obtener las frecuencias de tres intervalos con límites 150, 170, 180 y 190 se especifica en el parámetros `breaks` los límites. El código para obtener la segunda tabla de frecuencias se muestra a continuación.

```{r}
res2 <- hist(x=x, plot=FALSE, 
             breaks=c(150, 170, 180, 190))
res2
```

### Ejemplo {-}
Construya el vector `x` con los siguientes elementos: 1.0, 1.2, 1.3, 2.0, 2.5, 2.7, 3.0 y 3.4. Obtenga varias tablas de frecuencia con la función `hist` variando los parámetros `include.lowest` y `right`. Use como límite de los intervalos los valores 1, 2, 3 y 4.

Lo primero que debemos hacer es crear el vector `x` solicitado así:

```{r}
x <- c(1.1, 1.2, 1.3, 2.0, 2.0, 2.5, 2.7, 3.0, 3.4)
```

En la Figura \@ref(fig:dots) se muestran los `r length(x)` puntos y con color azul se representan los límites de los intervalos.

```{r dots, fig.cap='Ubicación de los puntos del ejemplo con límites en color azul.', fig.asp=0.8, fig.width=5, echo=F}
dotchart(x, xlab='Valores de x', xlim=c(0.5, 4.5), pch=19)
abline(v=c(1, 2, 3, 4), lty='longdash', col='blue')
```

A continuación se presenta el código para obtener la tabla de frecuencia usando `rigth=TRUE`, los resultados se almacenan en el objeto `res3` y se solicitan sólo los dos primeros elementos que corresponden a los límites y frecuencias. 

```{r}
res3 <- hist(x, breaks=c(1, 2, 3, 4), right=TRUE, plot=FALSE)
res3[1:2]
```

Ahora vamos a repetir la tabla pero usando `rigth=FALSE` para ver la diferencia, en `res4` están los resultados.

```{r}
res4 <- hist(x, breaks=c(1, 2, 3, 4), right=FALSE, plot=FALSE)
res4[1:2]
```

Al comparar los últimos dos resultados vemos que la primera frecuencia es 5 cuando `right=TRUE` porque los intervalos se consideran cerrados a la derecha.

Ahora vamos a construir una tabla de frecuencia usando `FALSE` para los parámetros `include.lowest` y `right`.

```{r}
res5 <- hist(x, breaks=c(1, 2, 3, 4),
             include.lowest=FALSE, right=FALSE,
             plot=FALSE)
res5[1:2]
```

De este último resultado se ve claramente el efecto de los parámetros `include.lowest` y `right` en la construcción de tablas de frecuencia.

## EJERCICIOS {-}
Use funciones o procedimientos (varias líneas) de \proglang{R} para responder cada una de las siguientes preguntas.

En el Cuadro \@ref(tab:toy) se presenta una base de datos sencilla. Lea la base de datos usando la funcion `read.table` y construya lo que se solicita a continuación.

1. Construya una tabla de frecuencia absoluta para la variable pasatiempo.
2. Construya una tabla de frecuencia relativa para la variable fuma.
3. Construya una tabla de frecuencia relativa para las variables pasatiempo y fuma.
4. ¿Qué porcentaje de de los que no fuman tienen como pasatiempo la lectura.
5. ¿Qué porcentaje de los que corren no fuman?








<!--chapter:end:08_tablas.Rmd-->


# Medidas de tendencia central \label{central}

En este capítulo se mostrará cómo obtener las diferentes medidas de tendencia central con \proglang{R}.

Para ilustrar el uso de las funciones se utilizará una base de datos llamada __medidas del cuerpo__, esta base de datos cuenta con 6 variables registradas a un grupo de 36 estudiantes de la universidad. Las variables son: 

1. `edad` del estudiante (años),
2. `peso` del estudiante (kilogramos),
3. `altura` del estudiante (centímetros),
4. `sexo` del estudiante (Hombre, Mujer),
5. `muneca`: perímetro de la muñeca derecha (centímetros),
6. `biceps`: perímetro del biceps derecho (centímetros).

A continuación se presenta el código para definir la url donde están los datos, para cargar la base de datos en R y para mostrar por pantalla un encabezado (usando `head`) de la base de datos.

```{r}
url <- 'https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo'
datos <- read.table(file=url, header=T)
head(datos)  # Para ver el encabezado de la base de datos
```

## Media \index{media} \index{mean}
Para calcular la media de una variable cuantitativa se usa la función `mean`. Los argumentos básicos de la función `mean` son dos y se muestran a continuación.

```{r, eval=F}
mean(x, na.rm = FALSE)
```

En el parámetro `x` se indica la variable de interés para la cual se quiere calcular la media, el parámetro `na.rm` es un valor lógico que en caso de ser `TRUE`, significa que se deben remover las observaciones con `NA`, el valor por defecto para este parámetro es `FALSE`.


### Ejemplo {-}
Suponga que queremos obtener la altura media del grupo de estudiantes.

Para encontrar la media general se usa la función `mean` sobre el vector númerico `datos$altura`.  

```{r}
mean(x=datos$altura)
```

Del anterior resultado podemos decir que la estatura media o promedio de los estudiantes es `r mean(datos$altura)` centímetros.

### Ejemplo {-}
Suponga que ahora queremos la altura media pero diferenciando por sexo.  

Para hacer esto se debe primero dividir o partir el vector de altura según los niveles de la variable sexo, esto se consigue por medio de la función `split` y el resultado será una lista con tantos elementos como niveles tenga la variable sexo. Luego a cada uno de los elementos de la lista se le aplica la función `mean` con la ayuda de `sapply` o `tapply`. A continuación el código completo para obtener las alturas medias para hombres y mujeres.

```{r}
sapply(split(x=datos$altura, f=datos$sexo), mean)
```

El resultado es un vector con dos elementos, vemos que la altura media para hombres es `r mean(datos$altura[datos$sexo=='Hombre'])` centímetros y que para las mujeres es de  `r mean(datos$altura[datos$sexo=='Mujer'])` centímetros.

¿Qué sucede si se usa `tapply` en lugar de `sapply`? Substituya en el código anterior la función `sapply` por `tapply` y observe la diferencia entre los resultados.

### Ejemplo {-}
Suponga que se tiene el vector `edad` con las edades de siete personas y supóngase que para el individuo cinco no se tiene información de su edad, eso significa que el vector tendrá un `NA` en la quinta posición. 

¿Cuál será la edad promedio del grupo de personas?

```{r}
edad <- c(18, 23, 26, 32, NA, 32, 29)
mean(x=edad)
```

Al correr el código anterior se obtiene un error y es debido al símbolo `NA` en la quinta posición. Para calcular la media sólo con los datos de los cuales se tiene información, se incluye el argumento `na.rm = TRUE` para que R remueva los `NA`. El código correcto a usar en este caso es:

```{r}
mean(x=edad, na.rm=TRUE)
```

De este último resultado se obtiene que la edad promedio de los individuos es 26.67 años.

## Mediana \index{mediana} \index{median}
Para calcular la mediana de una variable cantitativa se usa la función `median`. Los argumentos básicos de la función `median` son dos y se muestran a continuación.

```{r, eval=F}
median(x, na.rm = FALSE)
```

En el parámetro `x` se indica la variable de interés para la cual se quiere calcular la mediana, el parámetro `na.rm` es un valor lógico que en caso de ser `TRUE`, significa que se deben remover las observaciones con `NA`, el valor por defecto para este parámetro es `FALSE`.

### Ejemplo {-}
Calcular la edad mediana para los estudiantes de la base de datos.

Para obtener la mediana usamos el siguiente código:
```{r}
median(x=datos$edad)
```
y obtenemos que la mitad de los estudiantes tienen edades mayores o iguales a `r median(x=datos$edad)` años.

El resultado anterior se pudo haber obtenido con la función `quantile` e indicando que se desea el cuantil 50 así:
```{r}
quantile(x=datos$edad, probs=0.5)
```

## Moda \index{moda}
La moda de una variable cuantitativa corresponde a valor o valores que más se repiten, una forma sencilla de encontrar la moda es construir una tabla de frecuencias y observar los valores con mayor frecuencia.

### Ejemplo  {-}
Calcular la moda para la variable edad de la base de datos de estudiantes.

Se construye la tabla con la función `table` y se crea el objeto `tabla` para almacenarla.
```{r}
tabla <- table(datos$edad)
tabla
```
Al mirar con detalle la tabla anterior se observa que el valor que más se repite es la edad de 25 años en 5 ocasiones. Si la tabla hubiese sido mayor, la inspección visual nos podría tomar unos segundos o hasta minutos y podríamos equivocarnos, por esa razón es mejor ordenar los resultados de la tabla.

Para observar los valores con mayor frecuencia de la tabla se puede ordenar la tabla usando la función `sort` de la siguiente manera:
```{r}
sort(tabla, decreasing=TRUE)
```
De esta manera se ve fácilmente que la variable edad es unimodal con valor de 25 años.


















<!--chapter:end:11_Med_Cen.Rmd-->

# Medidas de variabilidad \label{varia}

En este capítulo se mostrará cómo obtener las diferentes medidas de variabilidad con \proglang{R}.

Para ilustrar el uso de las funciones se utilizará la base de datos llamada __aptos2015__, esta base de datos cuenta con 11 variables registradas a apartamentos usados en la ciudad de Medellín. Las variables de la base de datos son: 

1. `precio`: precio de venta del apartamento (millones de pesos),
2. `mt2`: área del apartamento ($m^2$),
3. `ubicacion`: lugar de ubicación del aparamentos en la ciudad (cualitativa),
4. `estrato`: nivel socioeconómico donde está el apartamento (2 a 6),
5. `alcobas`: número de alcobas del apartamento,
6. `banos`: número de baños del apartamento,
7. `balcon`: si el apartamento tiene balcón (si o no),
8. `parqueadero`: si el apartamento tiene parqueadero (si o no),
9. `administracion`: valor mensual del servicio de administración (millones de pesos),
10. `avaluo`: valor del apartamento en escrituras (millones de pesos),
11. `terminado`: si el apartamento se encuentra terminado (si o no).

A continuación se presenta el código para definir la url donde están los datos, para cargar la base de datos en R y para mostrar por pantalla un encabezado (usando `head`) de la base de datos.

```{r}
url <- 'https://raw.githubusercontent.com/fhernanb/datos/master/aptos2015'
datos <- read.table(file=url, header=T)
head(datos)  # Para ver el encabezado de la base de datos
```

## Rango \index{rango} \index{range}
Para calcular el rango de una variable cuantitativa se usa la función `range`. Los argumentos básicos de la función `range` son dos y se muestran abajo.

```{r, eval=F}
range(x, na.rm = FALSE)
```

En el parámetro `x` se indica la variable de interés para la cual se quiere calcular el rango, el parámetro `na.rm` es un valor lógico que en caso de ser `TRUE`, significa que se deben remover las observaciones con `NA`, el valor por defecto para este parámetro es `FALSE`.

La función `range` entrega el valor mínimo y máximo de la variable ingresada y el valor de rango se puede obtener restando del valor máximo el valor mínimo.


### Ejemplo {-}
Suponga que queremos obtener el rango para la variable precio de los apartamentos.

Para obtener el rango usamos el siguiente código.

```{r}
range(datos$precio)
max(datos$precio) - min(datos$precio)
```
Del resultado anterior podemos ver que los precios de todos los apartamentos van desde `r min(datos$precio)` hasta `r max(datos$precio)` millones de pesos, es decir, el rango de la variable precio es `r max(datos$precio)-min(datos$precio)` millones de pesos.

### Ejemplo {-}
Suponga que queremos obtener nuevamente el rango para la variable precio de los apartamentos pero diferenciando por el estrato.

Primero vamos a crear una función auxiliar llamada `myrange` que calculará el rango directamente ($max - min$). Luego vamos a partir la información de los precios por cada estrato usando `split`, la partición se almacenará en la lista `precios`. Finalmente se aplicará la función `myrange` a la lista `precios` para obtener los rangos del precio por estrato socioeconómico. El código para realizar esto se muestra a continuación.

```{r}
myrange <- function(x) max(x) - min(x)
precios <- split(datos$precio, f=datos$estrato)
sapply(precios, myrange)
```
De los resultados podemos ver claramente que a medida que aumenta de estrato el rango (variabilidad) del precio de los apartamentos aumenta. Apartamentos de estrato bajo tienden a tener precios similares mientras que los precios de venta para apartamentos de estratos altos tienden a ser muy diferentes entre si.

## Desviación estándar muestral ($S$) \index{desviación} \index{sd}

Para calcular la desviación muestral de una variable cuantitativa se usa la función `sd`. Los argumentos básicos de la función `sd` son dos y se muestran abajo.

```{r, eval=F}
sd(x, na.rm = FALSE)
```

En el parámetro `x` se indica la variable de interés para la cual se quiere calcular la desviación estándar muestral, el parámetro `na.rm` es un valor lógico que en caso de ser `TRUE`, significa que se deben remover las observaciones con `NA`, el valor por defecto para este parámetro es `FALSE`.

### Ejemplo {-}
Suponga que queremos obtener la desviación estándar muestral para la variable precio de los apartamentos.

Para obtener la desviación solicitada usamos el siguiente código:

```{r}
sd(x=datos$precio)
```

### Ejemplo {-}
Calcular la desviación estándar __poblacional__ ($\sigma$) para el siguiente conjunto de 5 observaciones: 12, 25, 32, 15, 26.

Recordemos que las expresiones matemáticas para obtener $S$ y $\sigma$ son muy similares, la diferencia está en el denominador, para $S$ el denominador es $n-1$ mientras que para $\sigma$ es $n$. Teniendo esto en cuenta podemos calcular la desviación poblacional apoyándonos en la función `sd`, para esto podemos construir una función llamada `Sigma` que calcule la desviación poblacional, a continuación el código necesario.

```{r}
Sigma <- function(x) {
  n <- length(x)
  sd(x) * (n-1) / n
} 
```

Ahora para obtener la desviación estándar __poblacional__ de los datos usamos el siguiente código.

```{r}
y <- c(12, 25, 32, 15, 26)
Sigma(y)
```

## Varianza muestral ($S^2$) \index{varianza} \index{var}

Para calcular la varianza muestral de una variable cuantitativa se usa la función `var`. Los argumentos básicos de la función `var` son dos y se muestran abajo.

```{r, eval=F}
var(x, na.rm = FALSE)
```

En el parámetro `x` se indica la variable de interés para la cual se quiere calcular la varianza muestral, el parámetro `na.rm` es un valor lógico que en caso de ser `TRUE`, significa que se deben remover las observaciones con `NA`, el valor por defecto para este parámetro es `FALSE`.


### Ejemplo {-}
Suponga que queremos determinar cuál región en la ciudad presenta mayor varianza en los precios de los apartamentos.

Para realizar esto debemos usar en conjunto la función `split`, `sapply` y `var` ya que se quiere la varianza de una variable (`precio`) dado los valores de otra variable (`ubicacion`). El código para obtener las varianzas es el siguiente.

```{r}
precios <- split(datos$precio, f=datos$ubicacion)
sapply(precios, var)
```

De los resultados anteriores se nota que los apartamentos ubicados en el Poblado tienen la mayor variabilidad en el precio, este resultado se confirma al dibujar un boxplot para la variable precio dada la ubicación, en la Figura \@ref(fig:box1) se muestra el boxplot y se ve claramente la dispersión de los precios en el Poblado. El código usado para generar la Figura \@ref(fig:box1) se presenta a continuación.

```{r box1, fig.cap='Boxplot para el precio de los apartamentos dada la ubicación.', fig.asp=0.5, fig.width =10}
with(datos, boxplot(precio ~ ubicacion, ylab='Precio (millones)'))
```

### Ejemplo {-}
¿Son los resultados de la función `var` los mismos que los resultados de la función `sd` elevados al cuadrado?

La respuesta es __NO__. La función `sd` se aplica sólo a vectores mientras que la función `var` de puede aplicar tanto a vectores como a marcos de datos. Al ser aplicada a marcos de datos numéricos se obtiene una matriz en que la diagonal representa las varianzas de las de cada una de las variables mientras que arriba y abajo de la diagonal se encuentran las covarianzas entre pares de variables.

Por ejemplo, si aplicamos la función `var` al marco de datos sólo con las variables precio, área y avaluo se obtiene una matriz de dimensión $3 \times 3$, a continuación el código usado.

```{r}
var(datos[, c('precio', 'mt2', 'avaluo')])
```

Del anterior resultado se observa la matriz de varianzas y covarianzas de dimensión $3 \times 3$.


## Coeficiente de variación ($CV$) \index{coeficiente de variación}

El coeficiente de variación se define como $CV=s/\bar{x}$ y es muy sencillo de obtenerlo, la función `CV` mostrada abajo permite calcularlo.

```{r}
CV <- function(x, na.rm = FALSE) {
  sd(x, na.rm=na.rm) / mean(x, na.rm=na.rm)
}
```

### Ejemplo {-}
Calcular el $CV$ para el vector `w` definido a continuación.

```{r}
w <- c(5, -3, NA, 8, 8, 7)
```

Vemos que el vector `w` tiene 6 observaciones y la tercera de ellas es un `NA`. Lo correcto aquí es usar la función `CV` definida antes pero indicándole que remueva los valores faltantes, para eso se usa el siguiente código.

```{r}
CV(x=w, na.rm=T)
```








<!--chapter:end:12_Med_Var.Rmd-->

# Medidas de posición \label{posi}

En este capítulo se mostrará cómo obtener las diferentes medidas de posición con \proglang{R}.

Para ilustrar el uso de las funciones se utilizará una base de datos llamada __medidas del cuerpo__, esta base de datos cuenta con 6 variables registradas a un grupo de 36 estudiantes de la universidad. Las variables son: 

1. `edad` del estudiante (años),
2. `peso` del estudiante (kilogramos),
3. `altura` del estudiante (centímetros),
4. `sexo` del estudiante (Hombre, Mujer),
5. `muneca`: perímetro de la muñeca derecha (centímetros),
6. `biceps`: perímetro del biceps derecho (centímetros).

A continuación se presenta el código para definir la url donde están los datos, para cargar la base de datos en R y para mostrar por pantalla un encabezado (usando `head`) de la base de datos.

```{r}
url <- 'https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo'
datos <- read.table(file=url, header=T)
head(datos)  # Para ver el encabezado de la base de datos
```

## Cuantiles \index{cuantiles} \index{quantile} \index{cuartiles} \index{deciles}  \index{percentiles} 

Para obtener cualquier cuantil (cuartiles, deciles y percentiles) se usa la función `quantile`. Los argumentos básicos de la función `quantile` son tres y se muestran a continuación.

```{r, eval=F}
quantile(x, probs, na.rm = FALSE)
```

En el parámetro `x` se indica la variable de interés para la cual se quieren calcular los cuantiles, el parámetro `probs` sirve para definir los cuantiles de interés y el parámetro `na.rm` es un valor lógico que en caso de ser `TRUE`, significa que se deben remover las observaciones con `NA`, el valor por defecto para este parámetro es `FALSE`.

### Ejemplo {-}
Suponga que queremos obtener el percentil 5, la mediana y el decil 8 pa la altura del grupo de estudiantes.

Se solicita el percentil 5, la mediana que es el percentil 50 y el decil 8 que corresponde al percentil 80, por lo tanto es necesario indicarle a la función `quantile` que calcule los cuantiles para las ubicaciones 0.05, 0.5 y 0.8, el código para obtener las tres medidas solicitadas es el siguiente.

```{r}
quantile(x=datos$altura, probs=c(0.05, 0.5, 0.8))
```






<!--chapter:end:13_Med_Pos.Rmd-->

# Medidas de correlación \label{correl}

En este capítulo se mostrará cómo obtener el coeficiente de correlación lineal para variables cuantitativas.

## Función `cor` \index{cor} \index{correlación}
La función `cor` permite calcular el coeficiente de correlación de Pearson, Kendall o Spearman para dos variables cuantitativas. La estructura de la función es la siguiente.

```{r, eval=F}
cor(x, y, use="everything",
    method=c("pearson", "kendall", "spearman"))
```

Los parámetos de la función son:

- `x, y`: vectores cuantitativos.
- `use`: parámetro que indica lo que se debe hacer cuando se presenten registros `NA` en alguno de los vectores. Las diferentes posibilidades son: `everything`, `all.obs`, `complete.obs`, `na.or.complete` y `pairwise.complete.obs`, el valor por defecto es `everything`.
- `method`: tipo de coeficiente de correlación a calcular, por defecto es `pearson`, otros valores posibles son `kendall` y `spearman`.

### Ejemplo {-}
Calcular el coeficiente de correlación de Pearson para las variables área y precio de la base de datos sobre apartamentos usados.

Lo primero que se debe hacer es cargar la base de datos usando la url apropiada. Luego de esto se usa la función `cor` sobre las variables de interés. A continuación se muestra el código necesario.

```{r}
url <- 'https://raw.githubusercontent.com/fhernanb/datos/master/aptos2015'
datos <- read.table(file=url, header=T)
cor(x=datos$mt2, y=datos$precio)
```

Del resultado anterior vemos que existe una correlación de `r cor(x=datos$mt2, y=datos$precio)` entre las dos variables, eso significa que apartamentos de mayor área tienden a tener precios de venta más alto. Este resultado se ilustra en la Figura \@ref(fig:disp), se nota claramente que la nube de puntos tiene un pendiente positiva y por eso el signo del coeficiente de correlación.

A continuación el código para generar la Figura \@ref(fig:disp).

```{r disp, fig.cap='Diagrama de dispersión para precio versus área de los apartamentos usados.', fig.asp=0.6, fig.width =10}
with(datos, plot(x=mt2, y=precio, pch=20, col='blue',
                 xlab='Área del apartamento', las=1,
                 ylab='Precio del apartamento (millones COP)'))
```

### Ejemplo {-}
Para las mismas variables del ejemplo anterior calcular los coeficientes de correlación Kendall y Spearman.

A continuación el código para obtener lo solicitado.

```{r}
cor(x=datos$mt2, y=datos$precio, method='pearson')
cor(x=datos$mt2, y=datos$precio, method='kendall')
cor(x=datos$mt2, y=datos$precio, method='spearman')
```

### Ejemplo {-}
Para la base de datos de apartamentos usados, ¿cuáles de las variables cuantitativas tienen mayor correlación?

Lo primero que debemos hacer es determinar cuáles son las cuantitativas de la base de datos. Para obtener información de las variables que están almacenadas en el marco de datos llamado `datos` usamos la función `str` que muestra la estructura interna de objeto.

```{r}
str(datos)
```

Del anterior resultado vemos que las variables precio, mt2, alcobas, banos, administracion y avaluo son las variables cuantitativas, las restantes son cualitativas (nominal u ordinal). Las posiciones de las variables cuantitativas en el objeto `datos` son 1, 2, 5, 6, 9, 10, así podemos construir un marco de datos sólo con la información cuantitativa, a continuación el código usado.

```{r}
datos.cuanti <- datos[, c(1, 2, 5, 6, 9, 10)]
# La siguiente instrucción para editar los nombres de la variables
colnames(datos.cuanti) <- c('Precio', 'Área', 'Alcobas',
                            'Baños', 'Admon', 'Avaluo')
M <- round(cor(datos.cuanti), digits=2)
M
```

El anterior resultado representa la matriz de correlaciones entre las variables cuantitativas, se observa que la mayor correlación es entre las variables precio y área del apartamento.

Es posible representar gráficamente la matriz de correlaciones `M` por medio de la función `corrplot` del paquete **corrplot**\index{corrplot} [@R-corrplot], a continuación el código para obtener su representación gráfica.

```{r corplot, fig.cap='Matriz de coeficientes de correlación.', fig.asp=0.6, fig.width=6}
library('corrplot')  # Para cargar el paquete corrplot
corrplot.mixed(M)
```

En la Figura \@ref(fig:corplot) se muestra la matriz con los coeficientes de correlación. En la diagonal de la Figura \@ref(fig:corplot) están las variables, por encima están unos círculos de colores, entre más intensidad del color, ya sea azul o rojo, mayor es la correlación, colores ténues significan correlación baja; el tamaño de los círculos está asociado al valor absoluto de correlación. Por debajo de la diagonal se observan los valores exactos de correlación en colores.

```{block2, type='rmdtip'}
La función `corrplot` es muy versátil, se pueden obtener diferentes representaciones gráficas de la matriz de correlaciones, para conocer las diferentes posibilidades recomendamos consultar este enlace: https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html.
```

### Ejemplo {-}
Construya dos vectores hipotéticos con el gasto y ahorro de un grupo de 7 familias, incluya dos `NA`. Calcule el coeficiente de correlación entre `ahorro` y `gasto`, use el parámetro `use` para manejar los `NA`.

A continuación se presenta el código para crear los objetos `ahorro` y `gasto` con datos ficticios. Observe que en el primer caso donde se calcula la correlación no es posible obtener un resultado debido a que por defecto `use='everything'` y por lo tanto usa todas las observaciones incluyendo los `NA`. En el segundo caso si se obtiene un valor para la correlación debido a que se usó `use='complete.obs'`.

```{r}
gasto <- c(170, 230, 120, 156, 256, NA, 352)
ahorro <- c(45, 30, NA, 35, 15, 65, 15)

cor(gasto, ahorro)
cor(gasto, ahorro, use='complete.obs')
```


## EJERCICIOS {-}
Use funciones o procedimientos (varias líneas) de \proglang{R} para responder cada una de las siguientes preguntas.

1. Para cada uno de los estratos socioeconómicos, calcular el coeficiente de correlación lineal de Pearson para las variables precio y área de la base de datos de los apartamentos usados.

2. Calcular los coeficientes de correlación Pearson, Kendall y Spearman para las variables cuantitativas de la base de datos sobre medidas del cuerpo explicada en el Capítulo \@ref(central). La url con la información es la siguiente: https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo

3. Represente gráficamente las matrices de correlación obtenidas en el ejercicio anterior.

<!--chapter:end:14_Med_Cor.Rmd-->

# Distribuciones discretas

En este capítulo se mostrarán las funciones de \proglang{R} para distribuciones discretas.

## Funciones disponibles para distribuciones discretas \index{distribuciones discretas}
Para cada distribución discreta hay disponibles 4 funciones, a continuación se muestra el listado de funciones y su utilidad.

```{r, eval=F}
dxxx(x, ...)  # Función de masa de probabilidad, f(x)
pxxx(q, ...)  # Función de distribución acumulada hasta q, F(x)
qxxx(p, ...)  # Cuantil para el cual P(X <= q) = p
rxxx(n, ...)  # Generador de números aleatorios.
```

En el espacio de las letras `xxx` se de debe colocar el nombre de la distribución en \proglang{R}, a continuación el listado de nombres disponibles para las 5 distribuciones discretas básicas.

```{r, eval=F}
binom     # Binomial
geo       # Geométrica
nbinom    # Binomial negativa
hyper     # Hipergeométrica
pois      # Poisson
multinom  # Multinomial
```

Combinando las funciones y los nombres se tiene un total de 24 funciones, por ejemplo, para obtener la función de masa de probabilidad $f(x)$ de una binomial se usa la función `pbinom( )` y para obtener la función acumulada $F(x)$ de una Poisson se usa la función `dpois( )`.

### Ejemplo binomial {-}
Suponga que un grupo de agentes de tránsito sale a una vía principal para revisar el estado de los buses de transporte intermunicipal. De datos históricos se sabe que un 10\% de los buses generan una mayor cantidad de humo de la permitida. En cada jornada los agentes revisan siempre 18 buses, asuma que el estado de un bus es independiente del estado de los otros buses.

1) Calcular la probabilidad de que se encuentren exactamente 2 buses que generan una mayor cantidad de humo de la permitida.

Aquí se tiene una distribucion $Binomial(n=18, p=0.1)$ y se desea calcular $P(X=2)$. Para obtener esta probabilidad se usa la siguiente instrucción.

```{r}
dbinom(x=2, size=18, prob=0.10)
```

Así $P(X=2)=0.2835$.

2) Calcular la probabilidad de que el número de buses que sobrepasan el límite de generación de gases sea al menos 4.

En este caso interesa calcular $P(X \geq 4)$, para obtener esta probabilidad se usa la siguiente instrucción.

```{r}
sum(dbinom(x=4:18, size=18, prob=0.10))
```

Así $P(X \geq 4)=0.0982$

3) Calcular la probabilidad de que tres o menos buses emitan gases por encima de lo permitido en la norma.

En este caso interesa $P(X\leq3)$ lo cual es $F(x=3)$, por lo tanto, la instrucción para obtener esta probabilidad es

```{r}
pbinom(q=3, size=18, prob=0.10)
```

Así $P(X\leq3)=F(x=3)=0.9018$

4) Dibujar la función de masa de probabilidad.

Para dibujar la función de masa de probabilidad para una $Binomial(n=18, p=0.1)$ se usa el siguiente código.

```{r binom1, fig.cap='Función de masa de probabilidad para una $Binomial(n=18, p=0.1)$.', fig.asp=0.7, fig.width=8}
x <- 0:18  # Soporte (dominio) de la variable
Probabilidad <- dbinom(x=x, size=18, prob=0.1)
plot(x=x, y=Probabilidad, 
     type='h', las=1, lwd=6)
```

En la Figura \@ref(fig:binom1) se muestra la función de masa de probabilidad para la $Binomial(n=18, p=0.1)$, de esta figura se observa claramente que la mayor parte de la probabilidad está concentrada para valores pequeños de $X$ debido a que la probabilidad de éxito individual es $p=0.10$. Valores de $X \geq 7$ tienen una probabilidad muy pequeña y es por eso que las longitudes de sus barras son muy cortas.

5) Generar con 100 de una distribución $Binomial(n=18, p=0.1)$ y luego calcular las frecuencias muestrales y compararlas con las probabilidades teóricas.

La muestra aleatoria se obtiene con la función `rbinom` y los resultados se almacenan en el objeto `m`, por último se construye la tabla de frecuencias relativas, a continuación el código usado.

```{r}
m <- rbinom(n=100, size=18, prob=0.1)
m  # Para ver lo que hay dentro de m
prop.table(table(m))  # Tabla de frecuencia relativa
```
A pesar de ser una muestra aleatoria de sólo 100 observaciones, se observa que las frecuencias relativas obtenidas son muy cercanas a las mostradas en la Figura \@ref(fig:binom1).

### Ejemplo geométrica {-}
En una línea de producción de bombillos se sabe que sólo el 1\% de los bombillos son defectuosos. Una máquina automática toma un bombillo y lo prueba, si el bombillo enciende, se siguen probando los bombillos hasta que se encuentre __un__ bombillo defectuoso, ahí se para la línea de producción y se toman los correctivos necesarios para mejorar el proceso.

1) Calcular la probabilidad de que se necesiten probar 125 bombillos para encontrar el primer bombillo defectuoso.

En la distribución geométrica, la variable $X$ representa el número de fracasos antes de encontrar el único éxito, por lo tanto, en este caso el interés es calcular $P(X=124)$. La instrucción para obtener esta probabiliad es la siguiente.

```{r}
dgeom(x=124, prob=0.01)
```

2) Calcular $P(X \leq 8)$.

En este caso interesa $P(X \leq 50)$ lo que equivale a $F(8)$, la instrucción para obtener la probabilidad es la siguiente.

```{r}
pgeom(q=50, prob=0.01)
```

3) Encontrar el cuantil $q$ tal que $P(X \leq q) = 0.40$.

En este caso interesa encontrar el cuantil $q$ que cumpla la condición de que hasta $q$ esté el 40\% de las observaciones, por esa razón se usa la función `qgeom` como se muestra a continuación.

```{r}
qgeom(p=0.4, prob=0.01)
```

```{block2, type='rmdnote'}
Note que las funciones `pxxx` y `qxxx` están relacionadas, `pxxx` entrega la probabilidad hasta el cuantil $q$ mientras `qxxx` entrega el cuantil en el que se acumula $p$ probabilidad.
```

### Ejemplo binomial negativa {-}
Una familia desea tener hijos hasta conseguir  __2 niñas__, la probabilidad individual de obtener una niña es 0.5 y se supone que todos los nacimientos son individuales, es decir, un sólo bebé.

1) Calcular la probabilidad de que se necesiten 4 hijos, es decir, 4 nacimientos para consguir las dos niñas.

En este problema se tiene una distribución binomial negativa con $r=2$ niñas, los éxitos deseados por la familia. La variable $X$ representa los fracasos, es decir los niños, hasta que se obtienen los éxitos $r=2$ deseados.

En este caso lo que interesa es $P(\text{familia tenga 4})$, en otras palabras interesa $P(X=2)$, la instrucción para calcular la probabilidad es la siguiente.

```{r}
dnbinom(x=2, size=2, prob=0.5)
```

2) Calcular $P(\text{familia tenga al menos 4 hijos})$.

Aquí interesa calcular $P(X \geq 2)=P(X=2)+P(X=3)+\ldots$, como esta probabilidad va hasta infinito, se debe usar el complemento así:

$$P(X \geq 2) = 1 - [P(X=0)+P(X=1)]$$
y para obtener la probabilidad solicitada se puede usar la función `dnbinom` de la siguiente manera.

```{r}
1 - sum(dnbinom(x=0:1, size=2, prob=0.5))
```

Otra forma para obtener la probabilidad solicitada es por medio de la función `pnbinom` de la siguiente manera.

```{r}
1 - pnbinom(q=1, size=2, prob=0.5)
```

### Ejemplo hipergeométrica {-}
Un lote de partes para ensamblar en una empresa está formado por 100 elementos del proveedor A y 200 elementos del proveedor B. Se selecciona una muestra de 4 partes al azar sin reemplazo de las 300 para una revisión de calidad.

1) Calcular la probabilidad de que todas las 4 partes de la muestra sean del proveedor A.

Aquí se tiene una situación que se puede modelar por medio de una distribución hipergeométrica con $m=100$ éxitos en la población, $n=200$ fracasos en la población y $k=4$ el tamaño de la muestra. El objetivo es calcular $P(X=4)$, para obtener esta probabilidad se usa la siguiente instrucción.

```{r}
dhyper(x=4, m=100, k=4, n=200)
```

2) Calcular la probabilidad de que dos o más de las partes sean del proveedor A.

Aquí interesa $P(X \geq 2)$, la instrucción para obtener esta probabilidad es.

```{r}
sum(dhyper(x=2:4, m=100, k=4, n=200))
```

### Ejemplo Poisson {-}
En una editorial se asume que todo libro de 250 páginas tiene en promedio 50 errores.

1) Encuentre la probabilidad de que en una página cualquiera no se encuentren errores.

Este es un problema de distribución Poisson con tasa promedio de éxitos dada por:

$$\lambda=\frac{50 \quad errores}{libro}=\frac{0.2 \quad errores}{pagina}$$
El objetivo es calcular $P(X=0)$, para obtener esta probabilidad de usa la siguiente instrucción.

```{r}
dpois(x=0, lambda=0.2)
```
Así $P(X=0)=0.8187$.

## Distribuciones discretas generales
En la práctica nos podemos encontramos con variables aleatorias discretas que no se ajustan a una de las distribuciones mostradas anteriormente, en esos casos, es posible manejar ese tipo de variables por medio de unas funciones básicas de \proglang{R} como se muestra en el siguiente ejemplo.

### Ejemplo {-}
El cangrejo de herradura hembra se caracteriza porque a su caparazón se adhieren los machos de la misma especie, en la Figura \@ref(fig:crab) se muestra una fotografía de este cangrejo. Los investigadores están interesado en determinar cual es el patrón de variación del número de machos sobre cada hembra, para esto, se recolectó una muestra de hembras a las cuales se les observó el color, la condición de la espina, el peso en kilogramos, el ancho del caparazón en centímetros y el número de satélites o machos sobre el caparazón, la base de datos está disponible en el siguiente [enlace](https://raw.githubusercontent.com/fhernanb/datos/master/crab).

```{r crab, echo=F, fig.cap='Fotografía del cangreo de herradura, tomada de http://sccoastalresources.com/home/2016/6/21/a-night-of-horseshoe-crab-tagging.', dpi=50, fig.align='center'}
knitr::include_graphics("images/crab.png")
```

1) Encontrar la distribución de probabilidad para la variable `Sa` que corresponde al número de machos sobre el caparazón de cada hembra.

Primero se debe leer la base de datos usando la url suministrada y luego se construye la tabla de frecuencia relativa y se almacena en el objeto `t1`.

```{r, echo=T}
url <- 'https://raw.githubusercontent.com/fhernanb/datos/master/crab'
crab <- read.table(file=url, header=T)

t1 <- prop.table(table(crab$Sa))
t1
```

La anterior tabla de frecuencias relativas se puede representar gráficamente usando el siguiente código.

```{r pmfcrab, fig.cap='Función de masa de probabilidad para el número de satélites por hembra.', fig.asp=0.7, fig.width=8}
plot(t1, las=1, lwd=5, xlab='Número de satélites',
     ylab='Proporción')
```

2) Sea $X$ la variable número de satélites por hembra, construir la función $F(x)$.

Para construir $F(x)$ se utiliza la función `ecdf` o _empirical cumulative density function_, a esta función le debe ingresar el vector con la información de la variable cuantitativa, a continuación del código usado. En la Figura \@ref(fig:Fcrab) se muestra la función de distribución acumulada para para el número de satélites por hembra.

```{r Fcrab, fig.cap='Función de distribución acumulada para el número de satélites por hembra.', fig.asp=0.7, fig.width=8}
F <- ecdf(crab$Sa)
plot(F, las=1, main='')
```

3) Calcular $P(X \leq 9)$.

Para obtener esta probabilidad se usa el objeto `F` que es en realidad una función, a continuación la instrucción usada.

```{r}
F(9)
```

Así $P(X \leq 9)=0.9595$.

4) Calcular $P(X > 4)$.

Para obtener esta probabilidad se usa el hecho de que $P(X > 4) = 1 - P(X \leq 4)$, así la instrucción a usar es.

```{r}
1 - F(4)
```

Por lo tanto $P(X > 4)=0.2775$.

5) Suponga que el grupo 1 está formado por las hembras cuyo ancho de caparazón es menor o igual al ancho mediano, el grupo 2 está formado por las demás hembras. ¿Será $F(x)$ diferente para los dos grupos?

Para realizar esto vamos a particionar el vector `Sa` en los dos grupos de acuerdo a la nueva variable `grupo` creada como se muestra a continuacion.

```{r}
grupo <- ifelse(crab$Wt <= median(crab$Wt), 'Grupo 1', 'Grupo 2')
x <- split(x=crab$Sa, f=grupo)
```

El objeto `x` es una lista y para acceder a los vectores allí almacenados usamos dos corchetes `[[]]`, uno dentro del otro. Luego para calcular $F(x)$ para los dos grupos se procede así:

```{r}
F1 <- ecdf(x[[1]])
F2 <- ecdf(x[[2]])
```

Para obtener las dos $F(x)$ en la misma figura se usa el código siguiente.

```{r Fcrabs, fig.cap='Función de distribución acumulada para el número de satélites por hembra diferenciando por grupo.', fig.asp=0.7, fig.width=8}
plot(F1, col='blue', main='', las=1)
plot(F2, col='red', add=T)
legend('bottomright', legend=c('Grupo 1', 'Grupo 2'),
       col=c('blue', 'red'), lwd=1)
```

En la Figura \@ref(fig:Fcrabs) se muestran las dos $F(x)$, en color azul para el grupo 1 y en color rojo para el grupo 2. Se observa claramente que las curvas son diferentes antes de $x=9$. El hecho de que la curva azul esté por encima de la roja para valores menores de 9, es decir, $F_1(x) \geq F_2(x)$, indica que las hembras del grupo 1 tienden a tener menos satélites que las del grupo 2, esto es coherente ya que las del grupo 2 son más grandes en su caparazón.





<!--chapter:end:21_DDisc.Rmd-->

# Distribuciones continuas

En este capítulo se mostrarán las funciones de \proglang{R} para distribuciones continuas.

## Funciones disponibles para distribuciones continuas

Para cada distribución continua hay disponibles 4 funciones, a continuación se muestra el listado de funciones y su utilidad.

```{r, eval=FALSE}
dxxx(x, ...)  # Función de densidad de probabilidad, f(x)
pxxx(q, ...)  # Función de distribución acumulada hasta q, F(x)
qxxx(p, ...)  # Cuantil para el cual P(X <= q) = p
rxxx(n, ...)  # Generador de números aleatorios.
```

En el espacio de las letras `xxx` se de debe colocar el nombre de la distribución en \proglang{R}, a continuación el listado de nombres disponibles para las 5 distribuciones discretas básicas.

```{r, eval=FALSE}
beta     # Beta
cauchy   # Cauchy
chisq    # Chi-cuadrada
exp      # Exponencial
f        # F
gamma    # Gama
lnorm    # log-normal
norm     # normal
t        # t-student
unif     # Uniforme
weibull  # Weibull
```

Combinando las funciones y los nombres se tiene un total de 44 funciones, por ejemplo, para obtener la función de densidad de probabilidad $f(x)$ de una normal se usa la función `pnorm( )` y para obtener la función acumulada $F(x)$ de una Beta se usa la función `dbeta( )`.

### Ejemplo beta {-}
 
Considere que una variable aleatoria $X$ se distribuye beta con parámetros $a=2$ y $b=5$.

1) Dibuje la densidad de la distribución.

La función `dbeta` sirve para obtener la altura de la curva de una distribución beta y combinándola con la función `curve` se puede dibujar la densidad solicitada. En la Figura \@ref(fig:beta1) se presenta la densidad, observe que para la combinación de parámetros $a=2$ y $b=5$ la distribución es sesgada a la derecha.

```{r beta1, fig.cap='Función de densidad para una $Beta(2, 5)$.', fig.asp=0.7, fig.width=6}
curve(dbeta(x, shape1=2, shape2=5), lwd=3, las=1,
      ylab='Densidad')
```

2) Calcular $P(0.3 \leq X \leq 0.7)$.

Para obtener la probabilidad o área bajo la densidad se puede usar la función `integrate`, los límites de la integral se ingresan en por medio de los parámetros `lower` y `upper`. Si la función a integrar tiene parámetros adicionales como en este caso, éstos se ingresan luego de los límites de la integral. A continuación el código necesario para obtener la probabiliad solicitada.

```{r}
integrate(f=dbeta, lower=0.3, upper=0.7,
          shape1=2, shape2=5)
```

Otra forma de obtener la probabilidad solicitada es restando de la probabilidad acumulada hasta el límite superior, la probabilidad acumulada hasta el límite inferior. Las probabilidades acumuladas hasta un valor dado se obtienen con la función `pbeta`, a continuación el código necesario.

```{r}
pbeta(q=0.7, shape1=2, shape2=5) - pbeta(q=0.3, shape1=2, shape2=5)
```

De ambas formas se obtiene que $P(0.3 \leq X \leq 0.7)=0.4092$.

```{block2, type='rmdnote'}
Recuerde que para distribuciones continuas

$$ P(a < X < b) = P(a \leq X < b) = P(a < X \leq b) = P(a \leq X \leq b)$$
```

### Ejemplo normal estándar {-}
Suponga que la variable aleatoria $Z$ se distribuye normal estándar, es decir, $Z \sim N(0, 1)$.

1) Calcular $P(Z < 1.45)$.

Para calcular la probabilidad se usa el siguiente código.

```{r}
pnorm(q=1.45)
```

En la Figura \@ref(fig:norm1) se muestra el área sombreada correspondiente a $P(Z < 1.45)$.

2) Calcular $P(Z > -0.37)$.

Para calcular la probabilidad se usa el siguiente código.

```{r}
1 - pnorm(q=-0.37)
```

En la Figura \@ref(fig:norm1) se muestra el área sombreada correspondiente a $P(Z > -0.37)$.

3) Calcular $P(-1.56 < Z < 2.58)$.

Para calcular la probabilidad se usa el siguiente código.

```{r}
pnorm(q=2.58) - pnorm(-1.56)
```

En la Figura \@ref(fig:norm1) se muestra el área sombreada correspondiente a $P(-1.56 < Z < 2.58)$.


```{r norm1, fig.cap='Área sombreada para los ejemplos.', fig.asp=1.1, fig.width=6, echo=FALSE, message=FALSE}
require(mytools)
par(mfrow=c(2, 2))
shadow.normal(lower=-5, upper=1.45, xlab='Z', ylab='Densidad',
              main='P(Z < 1.45)')
shadow.normal(lower=-0.37, upper=6, xlab='Z', ylab='Densidad',
              main='P(Z > -0.37)')
shadow.normal(lower=-1.56, upper=2.58, xlab='Z', ylab='Densidad',
              main='P(-1.56 < Z < 2.58)')
```

## Distribuciones continuas generales

En la práctica nos podemos encontramos con variables aleatorias continuas que no se ajustan a una de las distribuciones mostradas anteriormente, en esos casos, es posible manejar ese tipo de variables por medio de unas funciones básicas de \proglang{R} como se muestra en el siguiente ejemplo.

### Ejemplo {-}

En este ejemplo se retomará la base de datos `crab` sobre el cangrejo de herradura hembra presentado en el capítulo anterior. La base de datos `crab` contiene las siguientes variables: el color del caparazón, la condición de la espina, el peso en kilogramos, el ancho del caparazón en centímetros y el número de satélites o machos sobre el caparazón, la base de datos está disponible en el siguiente [enlace](https://raw.githubusercontent.com/fhernanb/datos/master/crab).

1) Sea $X$ la variable peso del cangrejo, dibuje la densidad para $X$.

Para obtener la densidad muestral de un vector cuantitativo se usa la función `density`, y para dibujar la densidad se usa la función `plot` aplicada a un objeto obtenido con `density`, a continuación el código necesario para dibujar la densidad.

```{r crabcont1, fig.cap='Función de densidad $f(x)$ para el peso de los cangrejos.', fig.asp=0.7, fig.width=6}
url <- 'https://raw.githubusercontent.com/fhernanb/datos/master/crab'
crab <- read.table(file=url, header=T)

plot(density(crab$W), main='', lwd=5, las=1,
     xlab='Peso (Kg)', ylab='Densidad')
```

En la Figura \@ref(fig:crabcont1) se muestra la densidad para la variable peso de los cangrejos, esta densidad es bastante simétrica y el intervalo de mayor densidad está entre 22 y 30 kilogramos.

2) Dibujar $F(x)$ para el peso del cangrejo.

Para dibujar la función $F(x)$ se usa la función `ecdf` y se almacena el resultado en el objeto `F`, luego se dibuja la función deseada usando `plot`. A continuación el código utilizado. En la Figura \@ref(fig:crabcont2) se presenta el dibujo para $F(x)$.

```{r crabcont2, fig.cap='Función acumulada $F(x)$ para el peso de los cangrejos.', fig.asp=0.7, fig.width=6}
F <- ecdf(crab$W)
plot(F, main='', xlab='Peso (Kg)', ylab='F(x)', cex=0.5, las=1)
```

3) Calcular la probabilidad de que un cangrejo hembra tenga un peso inferior o igual a 28 kilogramos.

Para obtener $P(X \leq 28)$ se evalua en la función $F(x)$ el cuantil 28 así.

```{r}
F(28)
```

Por lo tanto $P(X \leq 28)=0.7919$.

4) Dibujar la función de densidad para el peso de los cangrejos hembra diferenciando por el color del caparazón.

Como son 4 los colores de los caparazones se deben construir 4 funciones de densidad. Usando la función `split` se puede partir el vector de peso de los cangrejos según su color. Luego se construyen las cuatro densidades usando la función `density` aplicada a cada uno de los pesos, a continuación el código. 

```{r}
pesos <- split(x=crab$W, f=crab$C)
f1 <- density(pesos[[1]])
f2 <- density(pesos[[2]])
f3 <- density(pesos[[3]])
f4 <- density(pesos[[4]])
```

Luego de tener las densidades muestrales se procede a dibujar la primera densidad con `plot`, luego se usa la funció `lines` para agregar a la densidad inicial las restantes densidades. En la Figura \@ref(fig:crabcont3) se muestran las 4 densidades, una por cada color de caparazón.

```{r crabcont3, fig.cap='Función de densidad $f(x)$ para el peso del cangrejo diferenciando por el color.', fig.asp=0.7, fig.width=6}
plot(f1, main='', las=1, lwd=4,
     xlim=c(18, 34),
     xlab='Peso (Kg)', ylab='Densidad')
lines(f2, lwd=4, col='red')
lines(f3, lwd=4, col='blue')
lines(f4, lwd=4, col='orange')
legend('topright', lwd=4, bty='n',
       col=c('black', 'red', 'blue', 'orange'),
       legend=c('Color 1', 'Color 2', 'Color 3', 'Color 4'))
```

Otra forma para dibujar las densidades es usar el paquete **ggplot2** [@R-ggplot2]. En la Figura \@ref(fig:crabcont4) se muestra el resultado obtenido de correr el siguiente código.

```{r crabcont4, fig.cap='Función de densidad $f(x)$ para el peso del cangrejo diferenciando por el color y usando ggplot2.', fig.asp=0.7, fig.width=6, message=FALSE}
require(ggplot2)  # Recuerde que primero debe instalarlo

crab$Color <- as.factor(crab$C)  # Para convertir en factor

ggplot(crab, aes(x=W)) + 
  geom_density(aes(group=Color, fill=Color), alpha=0.3) +
  xlim(18, 34) + xlab("Peso (Kg)") + ylab("Densidad")
```

Para aprender más sobre el paquete **ggplot2** se recomienda consultar este [enlace](http://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html).

<!--chapter:end:22_DCont.Rmd-->

# Pruebas de bondad de ajuste

En este capítulo se 














<!--chapter:end:31_Bondad.Rmd-->

# Aproximación de integrales

En este capítulo se mostrará cómo aproximar integrales en una y varias dimensiones.

## Aproximación de Laplace unidimensional
Esta aproximación es útil para obtener el valor de una integral usando la expansión de Taylor para una función $f(x)$ unimodal en $\Re$, en otras palabras lo que interesa es:
$$ I = \int_{-\infty}^{\infty} f(x) d(x)$$
Al hacer una expansión de Taylor de segundo orden para $\log(f(x))$ en su moda $x_0$ el resultado es:
$$ \log(f(x)) \approx \log(f(x_0)) + \frac{\log(f)^\prime(x_0)}{1!} (x-x_0) + \frac{\log(f)^{\prime \prime}(x_0)}{2!} (x-x_0)^2 $$
El segundo término de la suma se anula porque $\log(f)^\prime(x_0)=0$ por ser $x_0$ el valor donde está el máximo de $\log(f(x))$. La expresión anterior se simplifica en:
$$ \log(f(x)) \approx \log(f(x_0)) + \frac{\log(f)^{\prime \prime}(x_0)}{2!} (x-x_0)^2 $$
al aislar $f(x)$ se tiene que

\begin{equation} \label{fx}
f(x) \approx f(x_0)  \exp \left( -\frac{c}{2} (x-x_0)^2 \right)
\end{equation}

donde $c=-\frac{d^2}{dx^2} \log(f(x)) \bigg|_{x=x_0}$.

La expresión \ref{fx} se puede reescribir de manera que aparezca el núcleo de la función de densidad de la distribución normal con media $x_0$ y varianza $1/c$, a continuación la expresión

$$
f(x) \approx f(x_0) \frac{\sqrt{2 \pi / c}}{\sqrt{2 \pi / c}}  \exp \left( -\frac{1}{2} \left( \frac{x-x_0}{1/\sqrt{c}} \right)^2 \right)
$$
Así al calcular la integral de $f(x)$ en $\Re$ se tiene que:
\begin{equation} \label{aprox_laplace}
I = \int_{-\infty}^{\infty} f(x) d(x) = f(x_0) \sqrt{2 \pi / c}
\end{equation}

### Ejemplo {-}
Calcular la integral de $f(x)=\exp \left( -(x-1.5)^2 \right)$ en $\Re$ utilizando la aproximación de Laplace.

Primero vamos a dibujar la función $f(x)$ para ver en dónde está su moda $x_0$.
```{r, fig.height=3, fig.width=4, fig.cap='Perfil de la función f(x).'}
fun <- function(x) exp(-(x-1.5)^2)
curve(fun, from=-5, to=5, ylab='f(x)', las=1)
```

Visualmente se nota que la moda está cerca del valor 1.5 y para determinar numéricamente el valor de la moda $x_0$ se usa la función `optimize`, los resultados se almacenan en el objeto `res`. El valor de la moda corresponde al elemento `maximum` del objeto `res`.
```{r}
res <- optimize(fun, interval=c(-10, 10), maximum=TRUE)
res
```
Para determinar el valor de $c$ de la expresión \ref{aprox_laplace} se utiliza el siguiente código.
```{r, message=FALSE}
require("numDeriv")
constant <- - as.numeric(hessian(fun, res$maximum))
```
Para obtener la aproximación de la integral se usa la expresión \ref{aprox_laplace} y para tener un punto de comparación se evalua la integral usando la función `integrate`, a continuación el código.
```{r}
fun(res$maximum) * sqrt(2*pi/constant)

integrate(fun, -Inf, Inf)  # Para comparar
```
De los anteriores resultados vemos que la aproximación es buena.



<!--chapter:end:51_Aprox_Int.Rmd-->

`r if (knitr:::is_html_output()) '# References {-}'`

```{r include=FALSE}
# generate a BibTeX database automatically for some R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```


<!--chapter:end:99-references.Rmd-->

